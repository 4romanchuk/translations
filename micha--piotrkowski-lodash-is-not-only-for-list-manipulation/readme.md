Это продолжение моего предыдущего поста про Функции высшего порядка в Lodash. Большиство людей знает Лодаш по конструкциям вроде такой:

Но Лодаш - это гораздо больше чем библиотека манипулирования списками. В этом после я хочу пролить свет на несколько менее популярные, но, по моему мнению, крайне полезные особенности Лодаш.

Disclaimer (отказ от ответственности): Эта статья предполагает, что читатель хорошо знаком с концепцией функций высшего порядка и знает, как работают такие функции, как _.curry и _.partial. Более того, в этой статье, когда я ссылаюсь на “Lodash”, я имею ввиду вариант lodash/fp библиотеки Lodash. Если вы никогда не слышали про lodash/fp, функции высшего порядка или просто хотите немного освежить свою память, пожалуйста взгляните на мою предыдущую статью по Функциям высшего порядка в Lodash.

Одна из вещей, которую я люблю в Lodash, это то, что она крайне гибкая и адаптируемая. Даже если она не имеет конкретной нужной вам функции, скорее всего вы можете построить ее за несколько строк кода. Авторы Lodash предоставили возможности расширения по всей кодовой базе, который позволяют разработчикам дальнейшую кастомизацию поведения. Одна из таких точек расширения - это Кастомизаторы.

Кастомизаторы.

Объектно-ориентированные программисты узнают Кастомизаторы как паттерн Стратегия из знаменитой книги “Банды четырех”: Приёмы объектно-ориентированного проектирования. Паттерны проектирования.

Кастомизаторы позволят вам значительно изменять поведения объекта, заменяя одну стратегию другой.

Давайте взглянем, как кастомизаторы работают на практике. Предположим, у нас есть разбитая по частям контактная информация, которую мы хотим объединить в один объект. Как вы можете ожидать, Лодаш уже предлагает функцию, которая делает эту работу за нас. Функция _.merge() объединяет два объекта, свойство за свойством:

Однако, если одинаковые свойства представлены в обоих объединяемых объектах, свойство из последнего объекта побеждает. В нашем примере это нежелательно, поскольку мы теряем информацию про один из телефонных номеров контакта.

 К счастью, существуею альтернативная версия функции _.merge(), которая принимает дополнительную функцию, которая позволяет кастомизировать способ, которым свойства будут объединены. Эта кастомизирующая функция будет вызываться для каждого свойства (а также и вложенных свойств), которые должны быть объединены (свойства из второго объединяемого объекта). Значения объединяемого свойства будут переданы в качестве первых двух параметров. Давайте попробуем:

Бонус: Другой вариант определения customizer: let customizer = _.cond([[_.isArray, _.concat]]);

Если одно из объединяемых свойств указывает на массив, тогда наш customizer возвращает новый массив, который содержит значения из обоих объединяемых объектов. Заметьте, что если объединяемое значение не массив, то наш customizer не будет возвращать никакого значения (или, другими словами, будет возвращать undefined). В такой ситуации Лодаш будет использовать стандартную стратегию (используемую в функции _.merge()).

Но почему мы должны ограничивать себя только конкатенацией массивов? Вот как мы можем сделать наш customizer более общим:

В этой новой версии customizer, если второй из объединяемых объектов содержит функцию, то вместо присвоения этой функции в результирующий объект, мы просто применяем ее передавая в качестве параметров значения соответствующего свойства из первого объекта.

Теперь мы можем передать наш customizer в качестве первого параметра функции _.mergeWith(). Давайте назовем получившуюся функцию patch:

Запомните, что все lodash/fp функции авто-каррируемы, так что мы можем передавать им подмножество параметров, а также заменители параметров _, и в результате мы будем получать результирующую функцию с некоторыми фиксированными параметрами.

Получившаяся функция patch() - это функция высшего порядка, которая возвращает новую функцию, трансформирующую объект в зависимости от предоставляемого параметра recipe. Параметр recipe формулируется довольно декларативным способом, но явно указывает, какую функцию использовать для объединения данного свойства. Если свойство указывает не на функцию, применяется стандартная стратегия объединения.

Заметка: порядок параметров в _.mergeWith(customizer, object, source) немного неудачный, посколько он принимается параметр с данными (object) вторым и не последним параметром. Иначе мы могли бы использовать плюсы от каррирования и определить функцию patch просто:

Однако, нужный порядок параметров заставляет нас пропустить второй параметр используя _.
Либо, мы могли мы переставить порядок параметров используя функцию _.rearg() таким образом:

Или просто (используя _.flip()):

_.flip и _.rearg() являются еще одним доказательством гибкости Лодаш.

OK, после того как мы определили нашу функцию patch(), давайте посмотрим, на что она способна. Мы начнем переделывать пример с контактной информацией:

Теперь, давайте вообразим, что мы хотим иметь возможность переключать флаг favorite для нашего контакта:

В Лодаш функиця _.mergeWith() рекурсивна, благодаря этому наша функция patch() поддерживает вложенные свойства из коробки:

Заметили, как мы избежали стандартных проверок на null?

Последним упражнением, давайте напишем функцию patch, которая попробует распарсить строку адреса и извлечь zip-код, улицу и город. Для построения цепочки операций (выполнения регулярного выражения, извлечения удовлевлетворяющих регулярному выражению групп в массив, построения объекта из массива) мы будет использовать функцию _.flow():

Теперь мы можем объединить все эти преобразования:

Мы можем также сделать это таким способом:


Сначала операции, в конце данные
Заметьте, как во всех наших примерах мы сначала определяем преобразования, затем комбинируем их, а в конце передаем нужные данные в получившееся преобразование. Само преобразование не зависит от данных, только от структуры принимаемых данных. Этот подход сильно отличается от более классического, объектно-ориентированного стиля, где операторы привязываются к некоторому контексту (например this или переменным из  родительской области видимости). В следующем примере  функция findActiveItems() зависит от массива items:

Эта зависимость от контекста делает функции менее переиспользуемыми, посколько они не могут быть отделены от их контекста. В отличие от объектно ориентированного стиля, в функциональном программировании мы пытаемся отделить операции от данных настолько, насколько это возможно. Один из способов достижения этого, это откладывать передачу данных на как можно более поздний момент. Это характерно для функциональных библиотек (таких как lodash/fp или Rambda) - принимать данные последним параметром.

Реализация списка To-Do.
Давайте возвратимся к нашей функции patch() и увидим, насколько далеко мы сможем продвинуть нашу простую реализацию. Насколько сложную логику мы сможем создать с использованием этой элементарной функции patch(), перед тем как мы возвратимся к более классическому (императивному) стилю программирования? В качестве теста давайте попробуем реализовать все возможности известного проекта TodoMVC. Конечно, мы сфокусируемся на деталях реализации модели/предметной области (domain/model), и пропустим все части, связанные с интерфейсом пользователя.

Давайте перечислим все функции списка To-Do, поддерживаемые TodoMVC:

создание новой записи,
пометка всех записей как завершенных,
удаление всех завершенных записей,
пометка записи как завершенной,
переименование записи,
удаление записи.

Мы будем идти по пунктам этого списка один за другим, но сначала определим, как наша модель в нашем списке To-Do будет выглядеть:

Создание новой записи
Добавление новой записи To-Do довольно прямолинейно после того, чему мы научились в предыдущих примерах

2. пометка всех записей как сделанных,
Сначала мы создадим функцию для завершения одной записи, а затем мы применим ее ко всем записям в списке:

Мы также создали альтернативное имя (alias) forAll для функции _.map, посколько это улучшает читаемость.

3. удаление всех завершенных записей
Удаление завершенных записей очень похоже на предыдущий пункт. Мы используем функцию _.matches() для фильтрации завершенных записей.

Похожим образом мы создали альтернативу removeIf для функции _.reject().

4. пометка записи как завершенной

Определение функции, которая переключает флаг выполнения записи, простое:

Переключение записи в списке To-Do и оставление остальных записей нетронутыми - это совершенно другая история. Чтобы сделать это, мы сначала создадим функцию высшего порядка, которая будет вызывать функцию, переданную в качестве параметра в зависимости от переданного предиката:

Функция onlyIf() выглядит излишне императивной. Возможно Лодаш может как-нибудь помочь нам с этим? Конечно может! Взгляните на _.cond(). Теперь мы имеем:

Теперь нам нужна еще одна функция:

Должен сказать, что otherwise() выглядит довольно экстремально. Возможно, императивная версия будет значительно более понятной. Я оставлю задачу (изменить эту функцию) читателю в качестве упражнения. Фрагмент otherwise(onlyIf(pow), _.isNumber), _.constant('number expected!') отнюдь не лучше. Он не выглядит естественно. Определенно он менее читаем, чем powN(n){ return _.isNumber(n) ? n * n : 'number expected!'}. Возможно мы зашли слишком далеко. Но давайте попробуем еще один трюк, перед тем как сдаваться. Давайте присвоим обе функции в Function.prototype и передадим исходную функцию как параметр this:

Нам пришлось поменять стрелочную нотацию (() => {}) на выражение с function, так как стрелочные функции не создают собственный параметр this. Теперь мы можем вернуться к нашему исходному заданию: переключение одной конкретной записи.

4a. Собственные функции соответствия
Как вы можете видеть в коде выше, чтобы завершить одну запись нам нужно передать ее полное название. Это немного неудобно. Что если мы хотим завершить каждую запись, содержащую “Learn” или “learn” в названии? Нам нужна собственная функция соответствия, которая также принимает регулярные выражения. Чтобы достигнуть этого, мы будем использовать уже знакомую функцию кастомизаторов Lodash, но в этот раз мы применим ее с функцией _.isMatchWith() вместо _.isMergeWith(.

Мы можем переиспользовать наш предыдущий кастомайзер и расширить его поддержкой регулярных выражений:


Наш улучшенный кастомайзер эффективно преобразовывает _.isMatchWith в нечно даже более гибкое чем _.conforms(), так как позволяет проверять соответствие свойств объекта с: фиксированными значениями, регулярными выражениями и предикатами:

5. Переименование записи + 6. Удаление записи
С придуманными ранее функциями-помощниками, оставшаяся функциональность крайне проста:

Все вместе
Давайте соберем все куски кода вместе. Я разделил определения функций на дву группы. Первая группа состоит из более абстрактных и более переиспользуемых функций (высшего порядка). Вторая группа включает в себя функции, более зависимые от предметной области.

Вы можете также найти полный код и поиграться с ним в этом JS Fiddle. 

Заключение

В этой статье мы исследовали возможности кастомизации библиотеки Lodash. В результате, мы сделали простой, но мощный domail-specific язык для декларативного преобразования JSON-объектов в виде патчей (patches). Благодаря гибкости и расширяемости Lodash, мы сделали это, написав довольно небольшое количество строк кода.

В конце мы смогли составить из очень простых функций более сложные патчи, которые читаются практически как естественный язык.

Является ли этот функциональный подход лучше/чище/моднее/подставьте свое прилагательное чем классический императивный подход? Я оставлю читателю этот вопрос на его усмотрение. Однако, независимо от ответа, это определенно важно быть в курсе всех этих крутых функций кастомизации предоставляемых Lodash.

В следующей статья мы расширим наш пример интерфейсом пользователя и построим полностью работоспособное приложение списка To-Do. Оставайтесь на связи!
