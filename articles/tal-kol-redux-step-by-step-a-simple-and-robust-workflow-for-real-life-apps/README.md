# Redux: шаг за шагом

*Redux стал одной самых популярных реализаций идей Flux'a для управления потоком данных в приложениях на реакте.
Однако изучая Redux'а можно попасть в некоторое замешательство, когда "из за деревьев мы не видим леса".
Далее будет представлено простое и продуманное рабочее окружение для работы с приложениями, использующими Redux.
На примерах мы шаг за шагом реализуем рабочее приложение. Попытаемся применить принципы Redux на практике и обосновать каждое решение*


## An opinionated approach for idiomatic Redux
[Redux](https://github.com/reactjs/redux) это не просто библтотека. Это целая экосистема. Одна из причин его популярности — это возсожность применять различные паттерны и подкоды к написанию кода. К примеру, если нужно совершить некоторые асинхронные действия, то что мне стоит использовать? [Санки](https://github.com/gaearon/redux-thunk)? Или может быть [промисы](https://github.com/acdlite/redux-promise)? Или [саги](https://github.com/redux-saga/redux-saga)?

Существует не один "правильный" ответ на вопрос какой подход "лучше". И нет "лучшего" пути использования Redux. Стоит сказать, что большой выбор подходов ставит в тупик. Я хочу показать свой личный вариант использования. Он понятный, применимы к самым разным  "живым" сценариям и, что самое главное, он прост в освоении.

## Итак, пора создать наже приложение!

Для продолжения нам нужен реальный пример. As long as we’re being opinionated, the most interesting place on the Internet is Reddit. Давайте, создамим приложение, показывающее самые популярные посты оттуда.

На первом экране будем выяснять у пользователя наиболее интересные темы.We’ll pull the list of topics from Reddit’s list of default front page subreddits.

ПОсле того, как пользователь сделает выбор, будем показывать список постов по выбранным темам (все посты либо посты по конкретной теме). По клику на пост в списке будем показывать его содержимое.

## Установка
Поскольку мы используем React, то для начала работы возьмем [Create React App](https://github.com/facebookincubator/create-react-app) — официальный стартовый шаблон. ТАкже установим [redux](), [react-redux]() и [redux-thunk]().

Добавим index.js, создадим в нем хранилище(store), подключим санки.

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { createStore, applyMiddleware, combineReducers } from 'redux';
import { Provider } from 'react-redux';
import thunk from 'redux-thunk';
import App from './App';
import './index.css';

import * as reducers from './store/reducers';
const store = createStore(combineReducers(reducers), applyMiddleware(thunk));

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```


### The Flux circle of life in a Redux app

Одна из главных вещей, которая часто упускается в различных Redux туториалах — а в каких, собственно говоря, случаях нам следует использовать Redux?
Redux является реализацией [Flux]()-архитектуры — паттерна для организации передачи данных в реакт-приложениях.

В классическом Fluxe для хранения состояния приложения используется хранилище(store). Передача действий(actions) вызывает изменение этого состояния. После чего происходит перендер представления(view), в соответствии с измененнным состоянием.

### Диагарамма флакса

Flux упрощает разработку, создавая однонаправленный поток данных. Это уменьшает [спагетти-эффект]() по мере роста кодовой базы приложения.

Одна из сложностей в понимании работы redux — это множоство интуитивно непонятных терминов типа *редьюсеров*, *селекторов* и *санков*. Для более четкого понимания взглянем на расширенную flux-диаграмму. Это просто различные redux инструменты:

### Диагарамма флакса рвсширенная

Как вы могли заметтить другие redux иннструменты типа миддлваров или саг не показаны. Это сделано намеренно, эьи инструменты не играют существенной роли в нашем приложении.

### Файловая структура проекта

Создадим корневую папку `/src` и в ней следующие подкаталоги:

`/src/components`

"Глупые" реакт-компоненты, не связанные с Redux

`/src/containers`
“Умные” реакт-компоненты, которые подключаются к Redux-хранилищу

`/src/services`
Некоторые абстракции для внешнего API (например backend-серверы)

`/src/store`
All Redux-specific code goes here, including all business-logic of our app
Весь специфичный для Redux код находится здесь, вкллючаю всю бизнес-логику нашего приложения

Папка `store` в свою очередь состоит из доменов, которые содержат:

`/src/store/{domain}/reducer.js`
Reducer as a default export with all selectors as named exports

Редюсеры экспортируемые по умолчанию со всеми селекторами, экспортируемыми с помощью именнованного экспорта.

`/src/store/{domain}/actions.js`
Все обработчики действий домена (санки и создание объектов)


## A state-first approach

Наше приложение иммеет две стадии. На первой мы предлагаем пользователю выбрать три темы. Мы можем начать с реализации любого элемента flux-диаграммы, для себя я выяснил, что проще всего начать с состояния (State).

Итак, какое состояние приложения требуется для первой стадии?

Нам нужно будет сохранитт список тем, полученных с сервера. Также нужно будет сохранить id выбранных пользователем тем (максимум 3 id). Будет хорошо сохранить порядок выбора. Например, если в нашем случае, уже выбрано 3 темы и пользователь выбирает еще, то мы будем удалять самую старую из выбранных тем.

Каким образом надо будет организовать эту структура состояния приложения? В моей предыдущей статье есть список полезных советов — [Avoiding Accidental Complexity When Structuring Your App State](). Руководствуясь этими советами получим следуюущую структуру:

```javascript
{
  "topicsByUrl": {
    "/r/Jokes/": {
      "title": "Jokes",
      "description": "The funniest sub on reddit. Hundreds of jokes posted each day, and some of them aren't even reposts! FarCraft"
    },
    "/r/pics/": {
      "title": "pics",
      "description": "I bet you can figure it out by reading the name of the subreddit"
    }
  },
  "selectedTopicUrls": ["/r/Jokes/"]
}
);
```
URL каждой темы будет служить уникальным id.

Где мы будем хранить это состояние? В redux есть редюсер (reducer) — это функция, котлря хранит состояние и обновляет его. Так как наш код будет организован по доменам, то редюсер будет лежать в : `/src/store/topics/reducer.js`.

Я приготовил шаблон для создания редьюсера, вы можете посмотреть на него [здесь](). Обратите внимание, что для обеспечения *иммутабельности* нашего состояние (как того требует Redux), я выбрал библиотеку [seamless-immutable]().


## Наш первый сценарий

После моделирования состояния, мы готовы продолжить реализовывать наще приложение. Давайте создадим компонент, выводящий на экран список, как только они появляются. Этот компонент будет подключен к редюсеру, это значит, что компонент "умный", т.е использующий Redux store (хранилище).
Создадим его в `/src/containers/TopicsScreen.js`.


Шаблон для создания "умного" компонента можно найти [здесь](). Так же нам надо будет вызвать его внутри корневого компонента [App]. Теперь, когда все настроено, попробуем получить несколько тем с сервера Reddit.

***Правило: Умные компоненты не должны содержать никакой логики, кроме передачи действий (dispatching actions)***

Наш сценарий начинает работу с использования `componentDidMount` — метода представления. Исходя из правила выше, мы не можем запускать логику прямо из представления. Поэтому, для получения списка тем, мы будем отправлять действие. Это действие является асинхронным и будет реализовано с помощью [санков]().

```javascript
import _ from 'lodash';
import * as types from './actionTypes';
import redditService from '../../services/reddit';

export function fetchTopics() {
  return async(dispatch, getState) => {
    try {
      const subredditArray = await redditService.getDefaultSubreddits();
      const topicsByUrl = _.keyBy(subredditArray, (subreddit) => subreddit.url);
      dispatch({ type: types.TOPICS_FETCHED, topicsByUrl });
    } catch (error) {
      console.error(error);
    }
  };
}
```

<!-- Указать про новый уровень абстракции для работы с АПИ  -->
Для удобства работы с API Reddit'a мы создадим новый сервис, получающий актуальное состояние сети. Это асинхронный метод и для него будем испольовать `await`. Мне нравится `async/await API`, по этой причине я уже давно не использую промисы.

*Сервис* возвращает нам массив, но наше приложение хранит список тем в виде `map`. Тело *действия* — это хорошее место для преобразования массива в map. Чтобы хранить данные в хранилище, мы должны вызвать наш редьюсер, передав объект — `TOPICS_FETCHED`.

Текущие исходники нашего приложения можно увидеть [здесь]()

## Несколько слов о сервисах

Как уже отмечалось ранее, сервисы используются для работы с внешним API. В большинстве случаев API, например как [это]() предоставляет Reddit.
Плюс от использования такого уровня абстракции в том, что наш код становится более независимым от изменений API. Если в будущем Reddit решить что то изменить (эндпоинт, названия полей), то эти изменения затронут только наши сервисы, а не все приложение целиком.

***Правило: Сервисы должны быть stateless (т.е должны не иметь состояния)***

Это довольно сложное правило в нашей методологии. Представим, что случится, если бы наше API требовало пароль. Мы могли бы сохранить состояние для логина с помощью данных для входа в систему внутри сервиса.

Однако наша методология разработки не позволила бы сделать это. Потому что все состояния приложения должны находиться в *хранилище*. Хранение данных внутри серивиса приведет к утечке хранилища. Приемлемым решением в этом случае будет передача каждого сервиса с данными для логина в виде аргумента и сохранения состояния логина в редьюсере.

Реализация сервиса довольно проста, увидеть ее можно [здесь]().

Завершение сценария — редьюсер и представление

Объект `TOPICS_FETCHED`, содержащий только что полученный список тем `topicsByUrl`, передается, как аргумент в редьюсер. Редьюсер не должен делать ничего, кроме сохранения этих данных:

```javascript
import * as types from './actionTypes';
import Immutable from 'seamless-immutable';

const initialState = Immutable({
  topicsByUrl: undefined,
  selectedTopicUrls: []
});

export default function reduce(state = initialState, action = {}) {
  switch (action.type) {
    case types.TOPICS_FETCHED:
      return state.merge({
        topicsByUrl: action.topicsByUrl
      });
    default:
      return state;
  }
}
```

Обратите внимание на использование `seamless-immutable`. Эта библиотека применяется для того, чтобы сделать наше изменение явным и понятным. Использование таких библтотек не является обазательным, я предпочитаю использовать прием со [спред-орператором]().

После того, как состояние обновилось, мы должны вызвать переендер представления. Это значит, что представление должно фиксировать изменения той части состояния от которого оно зависит. Это делается с помощью [mapStateToProps]().

```javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import * as topicsActions from '../store/topics/actions';
import * as topicsSelectors from '../store/topics/reducer';

class TopicsScreen extends Component {
  // view implementation here
}

// which props do we want to inject, given the global store state?
function mapStateToProps(state) {
  return {
    rowsById: topicsSelectors.getTopicsByUrl(state),
    rowsIdArray: topicsSelectors.getTopicsUrlArray(state)
  };
}

export default connect(mapStateToProps)(TopicsScreen);
```

Я решил что наше представление, будет отображать список тем с помощью отдельного компонента `ListView`, который принимает пропсы `rowsById` и `rowsIdArray`. Внутри `TopicsScreen` я использую `mapStateToProps` для обработски этих пропсов (далее они будут передаваться непосредственно в `ListView`). Пропсы могут быть получены из нашего состояния. Обратите внимание, что я не обоащаюсь с состоянияю напрямую...
