# Redux: шаг за шагом

*Redux стал одной самых популярных реализаций идей Flux'a для управления потоком данных в приложениях на React.
Однако, в процессе изучения Redux'а, часто возникает ситауция, когда "из за деревьев мы не видим леса".
Далее будет представлено простое и продуманное рабочее окружение для работы с приложениями, использующими Redux.
На примерах мы шаг за шагом реализуем рабочее приложение. Попытаемся применить принципы Redux на практике и обосновать каждое решение*


## An opinionated approach for idiomatic Redux
[Redux](https://github.com/reactjs/redux) это не просто библиотека. Это целая экосистема. Одна из причин его популярности — это возможность применять различные паттерны проектирования и подходы к написанию кода. К примеру, если нужно совершить некоторые асинхронные действия, то что мне стоит использовать? [Санки](https://github.com/gaearon/redux-thunk)? Или может быть [промисы](https://github.com/acdlite/redux-promise)? Или [саги](https://github.com/redux-saga/redux-saga)?

Какой подход верный? Единственного и четкого ответа нет. И нет "лучшего" пути использования Redux. Стоит сказать, что большой выбор подходов ставит в тупик. Я хочу показать свой личный вариант использования. Он понятный, применимый к самым разным  "живым" сценариям и, что самое главное, он прост в освоении.

## Итак, пора создать наже приложение!

Для продолжения нам нужен реальный пример. Давайте, создамим приложение, показывающее самые популярные посты с Reddit.

Работа приложения состоит из нескольких стадий.

На первой стадии будем выяснять у пользователя наиболее интересные темы.

После того, как пользователь сделает выбор, будем показывать список постов по выбранным темам (все посты либо посты по конкретной теме). По клику на пост в списке будем показывать его содержание.

## Установка
Поскольку мы используем React, то для начала работы возьмем [Create React App](https://github.com/facebookincubator/create-react-app) — официальный стартовый шаблон. ТАкже установим [redux](https://www.npmjs.com/package/redux), [react-redux](https://www.npmjs.com/package/react-redux) и [redux-thunk](https://www.npmjs.com/package/redux-thunk).

Добавим index.js, создадим в нем стор, подключим санки.

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { createStore, applyMiddleware, combineReducers } from 'redux';
import { Provider } from 'react-redux';
import thunk from 'redux-thunk';
import App from './App';
import './index.css';

import * as reducers from './store/reducers';
const store = createStore(combineReducers(reducers), applyMiddleware(thunk));

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```


### Жизненный цикл Flux'а в Redux-приложении

Одна из главных вещей, которая часто упускается в различных Redux туториалах — а где же место Redux в этом цикле?
Redux является реализацией [Flux](https://facebook.github.io/flux/)-архитектуры — паттерна для организации передачи данных в React-приложениях.

В классическом Flux'е для хранения стейта приложения используется стор. Диспатчинг(передача) экшенов вызывает изменение этого стейта. После чего происходит перендер представления, в соответствии с измененнным стейтом.

![Flux circle](images/cycle.jpg)

Flux упрощает разработку, создавая однонаправленный поток данных. Это уменьшает [спагетти-эффект](http://whatis.techtarget.com/definition/spaghetti-code) по мере роста кодовой базы приложения.

Одна из сложностей в понимании работы Redux — это множество неочевидных терминов типа *редюсеров*, *селекторов* и *санков*. Для более четкого понимания взглянем на расширенный Flux-цикл. Это просто различные redux инструменты:

![Flux circle extend](images/cycle2.jpg)

Как вы могли заметтить другие Redux-инструменты типа *миддлваров* или *саг* не показаны. Это сделано намеренно, эти инструменты не играют существенной роли в нашем приложении.

### Файловая структура проекта

Создадим корневую папку `/src` и в ней следующие подкаталоги:

`/src/components`

"Глупые" реакт-компоненты, не связанные с Redux

`/src/containers`
“Умные” реакт-компоненты, которые подключаются к Redux-хранилищу

`/src/services`
Некоторые абстракции для внешнего API (например, для бекенда)

`/src/store`
Весь специфичный для Redux код находится здесь, вкллючаю всю бизнес-логику нашего приложения

Папка `store` в свою очередь состоит из доменов, которые содержат:

`/src/store/{domain}/reducer.js`
Reducer as a default export with all selectors as named exports

Редюсеры экспортируемые по умолчанию и селекторы, экспортируемые с помощью именнованного экспорта.

`/src/store/{domain}/actions.js`
Все обработчики экшенов домена (санки и создание объектов)


## State-first подход

Наше приложение иммеет две стадии. На первой мы предлагаем пользователю выбрать три темы. Мы можем начать с реализации любого элемента Flux-цикла, но для себя я выяснил, что проще всего начать со *Стейта*.

Итак, какой стейт приложения требуется для первой стадии?

Нам нужно будет сохранить список тем, полученных с сервера. Также нужно будет сохранить id выбранных пользователем тем (максимум 3 id). Будет нелишним сохранить порядок выбора. Например, если в нашем случае, уже выбрано 3 темы и пользователь выбирает еще, то мы будем удалять самую старую из выбранных тем.

Каким образом будет стурктурно организован стейт приложения? В моей предыдущей статье есть список полезных советов — [Avoiding Accidental Complexity When Structuring Your App State](https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a#.cn46edbo4). Руководствуясь этими советами получим следуюущую структуру:

```javascript
{
  "topicsByUrl": {
    "/r/Jokes/": {
      "title": "Jokes",
      "description": "The funniest sub on reddit. Hundreds of jokes posted each day, and some of them aren't even reposts! FarCraft"
    },
    "/r/pics/": {
      "title": "pics",
      "description": "I bet you can figure it out by reading the name of the subreddit"
    }
  },
  "selectedTopicUrls": ["/r/Jokes/"]
}
);
```
URL каждой темы будет служить уникальным id.

Где мы будем хранить этот стейт? В redux есть редюсер (reducer) — это функция, которая хранит стейт и обновляет его. Так как наш код будет организован по доменам, то редюсер будет лежать в : `/src/store/topics/reducer.js`.

Я подготовил шаблон для создания редьюсера, вы можете посмотреть на него [здесь](https://github.com/wix/react-dataflow-example/blob/0ff3077d3de9a4b2c0f1174a3fa204fee05ed594/src/store/topics/reducer.js). Обратите внимание, что для обеспечения *иммутабельности* нашего состояние (как того требует Redux), я выбрал библиотеку [seamless-immutable](https://github.com/rtfeldman/seamless-immutable).


## Наш первый сценарий

После моделирования стейта, мы готовы продолжить реализовывать наше приложение. Давайте создадим компонент, выводящий на экран список тем, как только они появляются. Этот компонент будет подключен к редюсеру, это значит, что компонент "умный", т.е использующий Redux.
Создадим его в `/src/containers/TopicsScreen.js`.


Шаблон для создания "умного" компонента можно найти [здесь](https://github.com/wix/react-dataflow-example/blob/4151b3e702a002916f1d1579a2e33e0cf1cb0ba3/src/containers/TopicsScreen.js). Также нам надо будет вызвать его внутри корневого компонента [App](https://github.com/wix/react-dataflow-example/blob/57d53f2901e46ab2d90f756fd8c5988a5521e8e8/src/App.js). Теперь, когда все настроено, попробуем получить несколько тем с сервера Reddit.

**Правило: Умные компоненты не должны содержать никакой логики, кроме передачи действий (диспатчинг экшенов)**

Наш сценарий начинает работу с использования `componentDidMount` — метода представления. Исходя из правила выше, мы не можем запускать логику прямо из представления. Поэтому, для получения списка тем, мы будем диспатчить экшен. Это асинхронный экшен и он будет реализован с помощью [санков](https://github.com/gaearon/redux-thunk).

```javascript
import _ from 'lodash';
import * as types from './actionTypes';
import redditService from '../../services/reddit';

export function fetchTopics() {
  return async(dispatch, getState) => {
    try {
      const subredditArray = await redditService.getDefaultSubreddits();
      const topicsByUrl = _.keyBy(subredditArray, (subreddit) => subreddit.url);
      dispatch({ type: types.TOPICS_FETCHED, topicsByUrl });
    } catch (error) {
      console.error(error);
    }
  };
}
```

<!-- Указать про новый уровень абстракции для работы с АПИ  -->
Для удобства работы с API Reddit'a мы создадим новый сервис, получающий актуальное состояние сети. Это асинхронный метод и для него будем использовать `await`. Мне нравится `async/await API`, по этой причине я уже давно не использую промисы.

*Сервис* возвращает нам массив, но наше приложение хранит список тем в виде `map`. Тело *экшена* — это хорошее место для преобразования массива в map. Чтобы хранить данные в хранилище, мы должны вызвать наш редьюсер, передав объект — `TOPICS_FETCHED`.

Текущие исходники нашего приложения можно увидеть [здесь]()

## Несколько слов о сервисах

Как уже отмечалось ранее, сервисы используются для работы с внешним API. В большинстве случаев API, например как [это]() предоставляет Reddit.
Плюс от использования такого уровня абстракции в том, что наш код становится более независимым от изменений API. Если в будущем Reddit решить что то изменить (эндпоинт, названия полей), то эти изменения затронут только наши сервисы, а не все приложение целиком.

***Правило: Сервисы должны быть stateless (т.е должны не иметь состояния)***

Это довольно сложное правило в нашей методологии. Представим, что случится, если бы наше API требовало пароль. Мы могли бы сохранить состояние для логина с помощью данных для входа в систему внутри сервиса.

Однако наша методология разработки не позволила бы сделать это. Потому что все состояния приложения должны находиться в *хранилище*. Хранение данных внутри серивиса приведет к утечке хранилища. Приемлемым решением в этом случае будет передача каждого сервиса с данными для логина в виде аргумента и сохранения состояния логина в редьюсере.

Реализация сервиса довольно проста, увидеть ее можно [здесь]().

Завершение сценария — редьюсер и представление

Объект `TOPICS_FETCHED`, содержащий только что полученный список тем `topicsByUrl`, передается, как аргумент в редьюсер. Редьюсер не должен делать ничего, кроме сохранения этих данных:

```javascript
import * as types from './actionTypes';
import Immutable from 'seamless-immutable';

const initialState = Immutable({
  topicsByUrl: undefined,
  selectedTopicUrls: []
});

export default function reduce(state = initialState, action = {}) {
  switch (action.type) {
    case types.TOPICS_FETCHED:
      return state.merge({
        topicsByUrl: action.topicsByUrl
      });
    default:
      return state;
  }
}
```

Обратите внимание на использование `seamless-immutable`. Эта библиотека применяется для того, чтобы сделать наше изменение явным и понятным. Использование таких библтотек не является обазательным, я предпочитаю использовать прием со [спред-орператором]().

После того, как состояние обновилось, мы должны вызвать переендер представления. Это значит, что представление должно фиксировать изменения той части состояния от которого оно зависит. Это делается с помощью [mapStateToProps]().

```javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import * as topicsActions from '../store/topics/actions';
import * as topicsSelectors from '../store/topics/reducer';

class TopicsScreen extends Component {
  // view implementation here
}

// which props do we want to inject, given the global store state?
function mapStateToProps(state) {
  return {
    rowsById: topicsSelectors.getTopicsByUrl(state),
    rowsIdArray: topicsSelectors.getTopicsUrlArray(state)
  };
}

export default connect(mapStateToProps)(TopicsScreen);
```

Я решил что наше представление, будет отображать список тем с помощью отдельного компонента `ListView`, который принимает пропсы `rowsById` и `rowsIdArray`. Внутри `TopicsScreen` я использую `mapStateToProps` для обработски этих пропсов (далее они будут передаваться непосредственно в `ListView`). Пропсы могут быть получены из нашего состояния. Обратите внимание, что я не обращаюсь к состоянияю напрямую...

***"Умные" компоненты должны обращаться к состоянию только с помощью селекторов***

*Селекторы* один из самых главных инструментов Redux'а про который обычно забывают. Селектор это чистая функция, которая принимает в качестве аргумента глобальное состояние и возвращает его в преобразованном виде. Селекторы тесно связаны с редьюсерами и расположены внутри `reducer.js`. Селекторы позволяют нам провести некоторые расчеты по данным, прежде чем данные попадут в представление. В будущем мы используем этот прием.Каждый раз, когда нам необходимо получить часть состояния ( например в `mapStateToProps`), мы должны использовать селекторы.

Почему? Идея состоит в том, чтобы инкапсулировать внутренее состояние приложения и скрыть его от представления. Представьте, что позже мы решили изменить внутренюю структуру. Без селекторов нам пришлось бы рефакторить каждое представление, что нежелательно. Использование селекторов позволит проводить рефактор изменяя только редьюсер.

Сейчас `topics/reducer.js` выглядит так:

```javascript
import _ from 'lodash';

export default function reduce(state = initialState, action = {}) {
  // reducer implementation here
}

// selectors

export function getTopicsByUrl(state) {
  return state.topics.topicsByUrl;
}

export function getTopicsUrlArray(state) {
  return _.keys(state.topics.topicsByUrl);
}
```

Текущую стадию нашего приложения, включая `ListView`, можно увидеть [здесь]().

## Несколько слов о "тупых" компонентах

`ListView` хороший пример "тупого" компонента. Он не подключен к хранилищу и не использует Redux. В отличие от "умных" компонентов, тупые расположены в `/src/components`.

"Тупые" компоненты получают данные от родителя через пропсы и могут хранить локальное состояние. ***В оригинале тут текст про каретку, хз нужно ли переводить его***

Итак, когда же нам надо переходить от "умного" компонента к "тупому"?

***Правило: вся логика представления в умных компонентах должна выносится в тупой***

Если вы посмотрите на реализацию [ListView](), то вы можете увидеть некоторую логику, например итерацию строк. Мы должны использования такой логики внутри "умного" [TopicsScreen](). Такоей подход позволяет использоваться умных клмпонентам только как соединителям. Другой плюс такого подхода в том, что логика `ListView` становится переиспользуемой.

### Следующий сценарий — выбор нескольких тем

Первый сценарий завершен. Переходим к следующему — полльзователь может выбрать только 3 темы из списка.

Сценарий запускается, когда пользователь кликает по одной их тем. Это событие отлавливается в `TopicsScreen`, но т.к. умный компонент не может содержать никакой бизнес-логики, то мы должны отправить новое действие — `selectTopic`. Это действие тоже будет реализовано с помощью *санка*, разместим его в `topics/actions.js`. Как вы могли заметить, почти каждое действие, котороые мы экспортирукм (для передачи из представления) это санк.

``` javascript
export function selectTopic(topicUrl) {
  return (dispatch, getState) => {
    const selectedTopics = topicsSelectors.getSelectedTopicUrls(getState());
    if (_.indexOf(selectedTopics, topicUrl) !== -1) return;
    const newSelectedTopics = selectedTopics.length < 3 ?
      selectedTopics.concat(topicUrl) :
      selectedTopics.slice(1).concat(topicUrl);
    dispatch({ type: types.TOPICS_SELECTED, selectedTopicUrls: newSelectedTopics  });
  };
}
```

Важно отметить, что санку нужно получить доступ к состоянию. Также обратите внимание, что союлюдается правило по которому доступ в состоянию осуществляется через селектор.

Нам нужно будет обновить редьюсер таким образом, чтобы он мог обрабатывать `TOPICS_SELECTED`  и сохранять новые выбранные темы.Возникает вопрос, а должен ли `selectTopic` быть санком? Ведь мы можем сделать `selectTopic` простым объектом действия и передать его внурть редьюсера. Это правильный подход. Лично я предпочитаю хранить бизнес-логику в санках.

Обновив состояние, нам нужно вернуть список тем в наше предсиавление. Это значит, что нужно добавить выбранные темы в `mapStateToProps`. Поскольку представление должно каждый раз запрашивать, выбран ли `rowId` или нет, то более рпзумеым будет предавать эти данные в виде *map*. Т.к данные будут проходить черех селектор в люом случае, то именно там и выполним такое преобразование.

Реализуем вышеизложенную идею и добавим смену цвета фона при выборе темы внутри нового "тупого" компонента — `ListRow`. На этом этапе разработки наше приложение выглядит [так]().

### Несколько слов о бизнес-логике

Один из принципов хорошей методологии является разделение представления и бизнес-логики. Где на данный момент у нас реализована бизнес-логика?

Вся бизнес-логика находится в папке `src/store/`. Большая часть реализована в виде *санков* в `actions.js` и часть реализована внутри *селекторов* в `reducer.js`. Фактически — это официальное правило:

***Rule: Place all business logic inside action handlers (thunks), selectors and reducers. Вся бизнес-логика должна находиться внутри обработчиков событий(санков), селекторах и редьюсерах.***

### Переход к следующей стадии — список постов

Когда у нас больше обдного экрана, то нам нужная навигация. Зачастую для навишации испольхуется [react-router](). Я сознательно избегаю маршрутизации, чтобы не усложнять наше приложение. Выбор внешних зависимотстей, таких как маршрутизатор, как правило отвлекает от от основоного процесса разработки.


Вместо этого, давайте добавим переменную состояния `selectionFinalized`, уведомляющую нас о том что, завершился ли выбор тем или нет. Когда пользователь выберет три темы, мы покажем кнопку кликнув по которой, пользователь завершит выбор тем и перейдет к следующему экрану. Также при клике на кнопку будет отправлено действие, которое установит значение `selectionFinalized`.

Жто все похоже на то, что мы уже делали ранее, за искобчением одного — ьы должны згнать когда именно показвать кнопку (как только будет выбрано минимум 3 темы). Возможно у вас возникнет желание добавить новую перменную для этих целей. Это избыточно — эквивалетное значение мы уже можем получить из данных, котороые есть в состоянии. Это значит, что эту часть бизнес-логики мы должны реализовать, как селектор.

```javascript

export function isTopicSelectionValid(state) {
  return state.topics.selectedTopicUrls.length === 3;
}

```
Полная реализация того, о чем говорилось выше, находится [здесь](). Далее, чтобы сделать переключатель экранов, нужно превратить `App` в подключенный компонент, и с помощью `mapStateToProps` отлавливать изменения `selectionFinalized`. Более подробно смотрите [здесь]().

### The posts screen — once again state first

Поскольку мы теперь хорошо разбираемся в методологии, мы можем немного ускорить реализацию второго экрана. Новый экран работает с новым подкаталогом — *posts*. Чтобы сохранить модульность нашего приложения создадим для *posts* новый редьюсер и новый стейт.

Напоминание — задача второго экрана отобразить отобразить список постов, которые можно отфильтровать в зависимости от выбранной темы. Пользователь может кликнуть на пост в списке и увидеть его содержание. Следуя обозначенно ранее [структуре](), получаем следующее:

``` javascript

{
  "postsById": {
    "57jrtt": {
      "title": "My girlfriend left me because she couldn't handle my OCD.",
      "topicUrl": "/r/Jokes",
      "body": "I told her to close the door five times on her way out.",
    },
    "57l6oa": {
      "title": "Inception style vertical panoramas done with a quadcopter.",
      "topicUrl": "/r/pics",
      "thumbnail": "http://b.thumbs.redditmedia.com/h74JWprM3wljpdBOOpKDxt5sdZWPRtJBVULIobFfCBU.jpg",
      "url": "http://i.imgur.com/d1KUJI8.jpg"
    }
  },
  "currentFilter": "/r/Jokes",
  "currentPostId": "57jrtt"
}

```

И создаем новый редьюсер [здесь]().

### Первый сценарий — список постов без фильтрации

Наш стейт готов, теперь реализуем упрощенную версию сценария без фильтра.

Нам нужен уменый компонент для отображения постов, назовем егр `PostsScreen`, такжк нам нужно будет диспатчить новый экшен `fetchPosts`, когда у компонент будет вызван `componentDidMount`. Экшен будет санком, создадим его в `posts/actions.js`.

Это все очень похоже на то, что мы делали ранее. Реализация, по традиции, [здесь]().

В конце санка мы диспатчим простой экшен `POSTS_FETCHED`, который передает данные в редьюсер. Нужно будет доработать редьюсер, чтобы он мог сохранать данные. Далее нужно будет отобразить список постов в `PostsScreen`, для этого мы должный подключить `mapStateToProps` к селектору, который  отдаст нам нужную часть стейта. Далее мы можем отобразить список, повторно используя компонент ListView.

Впрочем, ничего нового — реализация на [месте].

### Следующий сценарий — фильтр постов

Сценария начинается с показа пользователю доступных фильтров. Мы можем получить данные, используя стейт редьюсера *тем* с помощью уже готового селектора. Когда фильтр будет выбран, мы диспатчим экшен, который изменит стейт с помощью редьюсера *постов*.

Особый интерес представляет для нас фильтрация списка постов. В стейте приложения мы сохраняем данные в виде `postsById` и `currentFilter`. Из этих данных можно получить отфильтрованный результат, поэтому сохранять в стейте приложения мы его не будем. Перед передачей в представление в `mapStateToProps`, бизнес логика будет запускаться в селекторе. СЛедовательно селектор будет выглдять так:

``` javascript

export function getPosts(state) {
  const currentFilter = state.posts.currentFilter;
  const postsById = state.posts.postsById;
  const postsIdArray = currentFilter === 'all' ?
    _.keys(postsById) :
    _.filter(_.keys(postsById), (postId) => postsById[postId].topicUrl === currentFilter);
  return [postsById, postsIdArray];
}

```

Полная реализация этого шага [здесь]().

### Последний сценарий — содержание поста

По правде говоря, это самый простой сценарий. В стейте приложения есть переменная `currentPostId`. Все, что нам нужно, это обновить эту переменную, сдиспатчив экшен, когда польщователь кликнет по посту. Эта переменная стейта понадобится в `PostsScreen`, чтобы показывать содержание поста. Это значит, что нам понадобится селектор, для управдения им в `mapStateToProps`.

Реализация [здесь]().


### Все готово

Код выше закрывает реализацию наешл приложения. Полная версия приложения доступна на GitHub: [https://github.com/wix/react-dataflow-example](https://github.com/wix/react-dataflow-example);

Какие выводы мы сделали:

* *Стейт приложения — это фундаментальная основа, [структурирующая]() приложения в виде базы данных*
* *Умные компоненты не должны содержать никакой логики, кроме диспатчинга экшенов*
* *Умные компоненты должны получчать доступ к стейту только через селекторы*
* *Логика представления в умных компонентах должна выноситься в тупые компоненты*
* *Вся бизнес-логика должна находиться в обработчиках экшенов(санках), селекторах и редьюсерах*
* *Сервисы не должный зависеть от стейта*

Помните, что Redux предосавляет большое поле для экспериментов. Существуют подходы отличное от того, что использовали мы. У меня есть друзья предпочитающие использовать *[redux-promise-middleware]()* вместо *санков* и писать безнес-логику тоьлко в редьюсерах.

Если вы хотите поделиться своей собственной методолигией для решения нашей задачи, не стесняйтесь — делайте PR в репозиторий проекта и мы рассмотрим его.
