# Итак, вы хотите научиться функциональному программированию (Часть 5)
*Перевод статьи [Charles Scalfani](https://medium.com/@cscalfani): [So You Want to be a Functional Programmer (Part 5)](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a) с [наилучшими пожеланиями от автора](https://twitter.com/cscalfani/status/933052963781722112).*

![Эволюция парадигм программирования](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png)

Первый шаг к пониманию идей функционального программирования – самый важный и иногда самый сложный шаг. Но с правильным подходом никаких трудностей быть не должно.

Предыдущие части: [Часть 1](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-1-6ef98e90d58d), [Часть 2](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-2-ae095d9807b3), [Часть 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158), [Часть 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da).

## Прозрачность ссылок

![Фактически, это замена](https://cdn-images-1.medium.com/max/800/1*4QRVgRMKN2che7VG8H5FxA.png)

***Прозрачность ссылок*** (*прим. пер., референциальная прозрачность*) -- выдуманный термин для описания возможности безопасной замены чистых функций их выражением. Пример наглядно продемонстрирует это.

В алгебре, когда у вас есть следующая формула:

```js
y = x + 10
```

И утверждается, что: 

```js
x = 3
```

Вы можете подставить `x` обратно в уравнение, чтобы получить:

```js
y = 3 + 10
```

Заметьте, что уравнение остаётся истинным. Мы можем делать подобные замены с чистыми функциями.

Вот функция на Elm, обособляющая одинарными кавычками предоставляемую строку:

```elm
quote str =
    "'" ++ str ++ "'"
```

И вот некоторый код, использующий её:

```elm
findError key =
    "Unable to find " ++ (quote key)
```

В этом примере `findError` создаст сообщение об ошибке, если поиск `key` не увенчался успехом.

Пока функция `quote` чистая, мы можем просто переместить вызов функции в `findError` вместе с телом функции `quote` (которое, по сути, выражение):

```js
findError key =
   "Unable to find " ++ ("'" ++ key ++ "'")
```

Это то, что я называю ***обратным рефакторингом*** (сюда я вкладываю достаточно широкий смысл) -- процесс, который может использоваться программистами или программами (такими как компиляторы или приложения для тестов), чтобы более осмысленно анализировать код.

Это может быть особенно полезным при анализе рекурсивных функций.

## Порядок выполнения

![Социальный агрегат в программировании](https://cdn-images-1.medium.com/max/800/1*k8zgyx2Mhlg6F82aSR9U4A.png)

Большинство программ однопоточны, то есть одна и только одна часть кода выполняется за определённый промежуток времени. Даже если у вас многопоточная программа, большинство потоков блокируется ожиданием выполнения процессов ввода-вывода, например, загрузкой файла, ответа сети и так далее.

Это одна из причин, почему мы должны естественно мыслить категориями пошаговой инструкции, когда пишем код:

```html
1. Достать хлеб
2. Положить два ломтика в тостер
3. Выбрать максимальную обжарку
4. Опустить рычаг
5. Подождать, пока тосты не вылетят
6. Вынуть тосты
7. Достать масло
8. Взять нож для масла
9. Намазать масло на тосты
```

В этом примере есть две независимые операции: использование масла и приготовление тостов. Они становятся взаимозависимыми только на девятом шаге.

Мы можем осуществить шаги семь и восемь параллельно с первым по шестой, пока они независимы один от другого.

Но, как только мы это делаем, всё становится куда более сложно:

```html
Поток 1
--------
1. Достать хлеб
2. Положить два ломтика в тостер
3. Выбрать максимальную обжарку
4. Опустить рычаг
5. Подождать, пока тосты не вылетят
6. Вынуть тосты

Поток 2
--------
1. Достать масло
2. Взять нож для масла
3. Подождать, пока поток 1 не выполнится
4. Намазать масло на тосты
```

Что случится со вторым потоком, если нарушится первый? Каков механизм взаимодействия двух потоков? Какому потоку всё-таки принадлежат тосты: первому, второму или обоим?

Легче всего не думать об этих структурных сложностях и оставить нашу программу выполнятся одним потоком.

Но когда выжать из программы всю возможную производительность для нас важно, мы должны приложить титанические усилия, чтобы написать для неё многопоточный программный код. 

Так или иначе, с многопоточностью есть две основные проблемы. Во-первых, многопоточные приложения сложно писать, анализировать, тестить и дебажить.

Во-вторых, такие языки, как JavaScript, не поддерживают многопоточность (*прим. пер., статья была написана в уже далёком 2016 году, и сейчас у нас есть большая надежда в виде [Napa.js](https://github.com/Microsoft/napajs)*), а те некоторые, что поддерживают, делают это плохо.

Но что если порядок не имеет значения и всё может выполняться параллельно?

Несмотря на то, что это звучит ненормально, это всё же не так сумбурно, насколько кажется. Давайте взглянем на некоторый код Elm, чтобы проиллюстрировать это:

```elm
buildMessage message value =
    let
        upperMessage =
            String.toUpper message

        quotedValue =
            "'" ++ value ++ "'"

    in
        upperMessage ++ ": " ++ quotedValue
```

Здесь `buildMessage` принимает `message` и `value`, затем приводит `message` к верхнему регистру, обрамляет `value` кавычками и конкатенирует эти строки, разделяя их символом двоеточия. 

Заметьте, что `upperMessage` и `quotedValue` независимы друг от друга. Откуда нам известно это?

Для условия независимости есть всего две истины. Во-первых, обе функции должны быть чистыми. Это важно, поскольку при выполнении они не должны влиять друг на друга.

Если они не будут чистыми, мы никогда не сможем сказать наверняка, являются ли они независимыми. В этом случае, мы вынуждены будем ориентироваться на тот порядок выполнения, которые они самостоятельно запустили в программе, чтобы определить его. Таким образом работают императивные языки программирования. 

Во-вторых, следующей истиной должно быть условие, при котором результат выполнения одной функции не является входным значением другой. Если это не так, нам придётся ждать конца выполнениия первой функции, чтобы запустилась вторая.

В таком ключе, `upperMessage` и `quotedValue` -- обе чистые функции, и ни одна из них не требует результата выполнения другой.

Следовательно, эти функции могут быть вызваны в ЛЮБОМ ПОРЯДКЕ.

Компилятор может определить порядок выполнения без какого-либо участия со стороны программиста. Это возможно только в чистом функциональном языке, потому как очень сложно, если вообще возможно, определять последствия побочных эффектов.

> *Порядок выполнения кода в чистом функциональном языке программирования может быть самостоятельно определён компилятором.*

Это чрезвычайно эффективно, учитывая, что процессоры не ускоряются. Вместо этого, процесс обработки подключает всё больше и больше ядер. Это означает, что код может выполняться параллельно на аппаратном уровне.

К несчастью, с императивными языками мы не можем в полной мере использовать мощь этих ядер, кроме как на очень грубом уровне. Но для этого требуется радикальным образом поменять архитектуру наших программ.

С чистым функциональным языком программирования у нас есть потенциал автоматически использовать преимущества ядер процессора на мелкомодульном уровне без изменения отдельной строки кода.

---

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/%D0%B4%D0%B5%D0%B2%D1%88%D0%B0%D1%85%D1%82%D0%B0/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

[Статья на GitHub](https://github.com/communar/translations/tree/master/articles/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-5)