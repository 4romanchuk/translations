# Асинхронные стэктрэйсы: почему `async` await бьет `.then()`.

*Перевод статьи [Mathias Bynens](https://mathiasbynens.be): [Asynchronous stack traces: why await beats .then()](https://mathiasbynens.be/notes/async-stack-traces). Опубликовано с разрешения автора.*

В сравнении использованием *промисов* напрямую, `async/await` не только делают код более читабельным для разработчиков, — он также добавляет некоторые оптимизации в движке Javascript.

Фундаментальное отличие между `await` и нативными промисами — то, что `await X()` приостанавливает выполнение текущей функции, когда `promise.then(X)` продолжает выполнение после объявления `X`, как *callback*'a цепочки *промисов*. Для стэктрэйса эта разница весьма значительная.

Когда цепочка промисов бросает необработанное исключение в любой момент, движок Javascript должен отобразить сообщение об ошибке и (вероятно) полезный стэктрэйс. Как разработчик, вы ожидаете этого, независимо от того, используете вы нативные промисы или же `async/await`.

## Нативные промисы

Представим сценарий, когда функция `c` была вызвана, в результате `resolve`’a асинхронного выполнения функции `b`.

```javascript
const a = () => {
  b().then(() => c());
};
```

Когда `a` была вызвана, следующее было выполнено синхронно:

- `b` была вызвана и вернула `Promise`, который выполнил `resolve` в некоторый момент времени в будущем.
- `.then` коллбэк, вызывающий функцию `c`, был добавлен в цепочку колбэков (или, говоря на языке V8 «был добавлен, как «*resolve handler*».)

После этого мы завершаем выполнение кода в теле функции `a`. `a` никогда не приостанавливается, из-за чего мы теряем контекст в результате aсинхронного вызова `resolve` функции `b`. Представьте, что будет, если `b` (или `c`) асинхронно бросит исключение. стэктрэйс должен включать информацию о функции `a`, т.к источник исключения `b` (или `c`), правильно? Как это возможно, когда ссылка на `a` потеряна?

Для того, чтобы этого избежать, движок Javascript должен сделать кое-что помимо перечисленных выше шагов: он захватывает и хранит стэктрэйс в пределах функции `a` до конца ее выполнения. В V8 стэктрэйс привязан к промису, возвращенному от `b`. По завершении промиса, стэктрэйс передается дальше, и `c` может использовать его по мере необходимости.

Захват стэктрэйса забирает время (следовательно, ухудшает производительность); хранение стэктрэйса требует памяти.


## `async/await`


Это та же программа, написанная с использованием `async/await` вместо нативных промисов.

```javascript
const a = async () => {
  await b();
  c();
};
```

C `await` нет необходимости хранить текущий стэктрэйс — достаточно хранить указатель от `b` на `a`. Во время выполнения `b`, `a` приостанавливается, что позволяет все еще иметь доступ к текущему контексту. Если `b` бросает исключение, стэктрэйс может быть восстановлен путем перемещения этих указателей. Если `c` бросает исключение, стэктрэйс будет сформирован точно также, как это бы было в случае с синхронным выполнением, так как в это время мы все еще находимся в внутри функции `a`.
Так или иначе, захват стэктрэйса больше не нужен — вместо этого, формирование стэктрэйса происходит тогда, когда это необходимо. 


## Рекомендации

Большинство ECMAScript фич являются «просто синтаксическим сахаром», `async/await` нечто большее.

Делайте так, чтобы Javascript движок мог обрабатывать стэктрэйсы более производительным и менее затратным к памяти способом следуя этим рекомендациям:

- Используйте `async/await` вместо нативных промисов.
- Используйте [babel-preset-env](babel-preset-env) для избежание транспайлига `async/await` без необходимости.

Несмотря на то, что V8 еще не реализует эту оптимизацию, следуя этим советам вы обеспечите оптимальную производительность, как только она появится.

Не используйте транспиляцию кода, пока вы действительно не испытываете в этом необходимость.
Например, [все современные браузеры, которые поддерживают *сервис воркеры*](https://caniuse.com/#feat=serviceworkers), также поддерживают `async/await`. В следствии чего, нет необходимости в транспиляции этого кода в нативные промисы. То же касается и [браузеров с поддержкой ES модулей](https://caniuse.com/#feat=es6-module). Для более детальной информации, смотрите пост Филлипа на [deploying ES2015+ code in production today](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/)

---

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

