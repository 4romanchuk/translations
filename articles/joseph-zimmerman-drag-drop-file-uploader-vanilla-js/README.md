# Как сделать Drag-and-Drop загрузчик файлов на чистом JavaScript

*Перевод статьи [Joseph Zimmerman](https://twitter.com/joezimjs): [How To Make A Drag-and-Drop File Uploader With Vanilla JavaScript](https://www.smashingmagazine.com/2018/01/drag-drop-file-uploader-vanilla-js/)*.

Известен факт, что поле загрузки файлов трудно стилизовать так, как хочется разработчику, многие просто скрывают его и добавляют кнопку, которая открывает диалог выбора файлов. Теперь, однако, у нас появился даже более модный способ обработки выбора файлов: drag and drop.

Технически, это уже было возможно сделать потому что большинство (если не все) реализаций поля выбора файлов позволяли перетаскивать файлы чтобы их выбрать, но это требовало от вас показывать элемент `file`. Так что давайте действительно использовать API, которое дает нам браузер, для реализации выбора файлов через drag-and-drop и их загрузчик.

В этой статье мы будем использовать чистый ES2015+ JavaScript (без фреймворков или библиотек) для завершения этого проекта, и это предполагает что у вас есть опыт работы с JavaScript в браузере. Этот пример — помимо ES2015+ синтаксиса, который можно легко изменить на синтаксис ES5 или транспилировать с помощью Babel — должен быть совместим со всеми вечнозелеными браузерами + IE 10 и 11.

Ниже пример того, что должно получиться:

![alt text](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8a415e72-c17f-4cc3-9b64-1c3ab14cf82c/uploader-preview.gif "Logo Title Text 1")

Демонстрационная страница на которой можно загрузить файлы с помощью drag and drop, предварительный просмотр изображений, загружаемых немедленно, и демонстрация прогресса в индикаторе загрузки.

## События Drag-and-Drop

Первое, что мы должны обсудить, - это события связаные с перетаскиванием, потому что они движущая сила этого функционала. В общем, есть восемь событий, срабатывающих в браузере и связанных с перетаскиванием: `drag`, `dragend`, `dragenter`, `dragexit`, `dragleave`, `dragover`, `dragstart` и `drop`. Мы не будем проходиться по ним всем, потому что события `drag`, `dragend`, `dragexit` и `dragstart` срабатывают на элементе, который перетаскивают, а это не наш случай, мы будем перетаскивать файлы из нашёй файловой системы вместо DOM элементов, так что эти события никогда не сработают.

Если эти события вас заинтересовали, то вы можете изучить [документацию связанную с ними на MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Drag_Events).

Как и следовало ожидать, вы можете зарегистрировать обработчики для нужных событий таким же образом, каким происходит регистрация обработчиков большинства браузерных событий: с помощью `addEventListener`.

```javascript
    let dropArea = document.getElementById('drop-area')
    dropArea.addEventListener('dragenter', handlerFunction, false)
    dropArea.addEventListener('dragleave', handlerFunction, false)
    dropArea.addEventListener('dragover', handlerFunction, false)
    dropArea.addEventListener('drop', handlerFunction, false)
```

Ниже приведена небольшая таблица описывающая что эти события делают, используем `dropArea` из примера кода для того, чтобы сделать язык чище:

| **Событие**     | **Когда оно срабатывает?**|
| ------------- |:-------------:|
| `dragenter`     | Перетаскиваемый объект перетаскивается над `dropArea`, делая `dropArea` источником возникновения события `drop`, если пользователь "бросит" его туда. |
| `dragleave`     | Перетаскиваемый объект перетащили за пределы `dropArea` на другой элемент, делая его источником возникновения события `drop` вместо `dropArea`.      |
| `dragover`      | Срабатывает каждые несколько сотен миллисекунд, пока объект перетаскивают над `dropArea`.     |
| `drop`          | Пользователь отпустил кнопку мыши, перетаскиваемый объект "бросили" на `dropArea`. |

Стоит отметить, что перетаскивании элемента над элементом, являющимся дочерним для `dropArea`, событие `dragleave` сработает над `dropArea`, а событие `dragenter` на дочернем элементе, потому что он становится `target`. Событие `drop` "всплывёт" до элемента `dropArea` (конечно, если до этого всплытие не остановит другой обработчик событий), так что событие сработает на `dropArea`, несмотря на то, что `target` у него будет другим.

Также обратите внимание, что для реализации пользовательских взаимодействий с перетаскиванием, вам необходимо вызывать `event.preventDefault()` на каждом из слушателей этих событий. Если вы этого не сделаете, то браузер в конечном итоге откроет файл, который вы перетаскиваете, вместо того, чтобы отправить его в обработчик события `drop`.

## Настраиваем нашу форму

До того как мы начнём добавлять функциональность drag-and-drop, нам надо добавить базовую форму со стандартным полем типа `file`. Технически это не обязательно, но это хорошая идея - предоставить такую альтернативу пользователям, чей браузер не поддерживает drag-and-drop API.

```html
<div id="drop-area">
  <form class="my-form">
    <p>Upload multiple files with the file dialog or by dragging and dropping images onto the dashed region</p>
    <input type="file" id="fileElem" multiple accept="image/*" onchange="handleFiles(this.files)">
    <label class="button" for="fileElem">Select some files</label>
  </form>
</div>
```

Довольно простая структура. Вы можете заметить обработчик события `onchange` на `input`. Посмотрим на него позже. Было бы также хорошей идеей добавить `action` к тегу `form` и кнопку `submit`, чтобы помочь людям, у которых выключен JavaScript. Тогда вы можете использовать JavaScript для того, чтобы избавиться от их чистой формы. В любом случае, вам *понадобится* серверный скрипт для загрузки файлов, не важно написан ли он дома или вы используете сервис, такой как [Cloudinary](https://cloudinary.com/documentation/javascript_image_and_video_upload). Кроме этих заметок, здесь нет ничего особенного, так что давайте набросаем стили:

```css
#drop-area {
  border: 2px dashed #ccc;
  border-radius: 20px;
  width: 480px;
  font-family: sans-serif;
  margin: 100px auto;
  padding: 20px;
}
#drop-area.highlight {
  border-color: purple;
}
p {
  margin-top: 0;
}
.my-form {
  margin-bottom: 10px;
}
#gallery {
  margin-top: 10px;
}
#gallery img {
  width: 150px;
  margin-bottom: 10px;
  margin-right: 10px;
  vertical-align: middle;
}
.button {
  display: inline-block;
  padding: 10px;
  background: #ccc;
  cursor: pointer;
  border-radius: 5px;
  border: 1px solid #ccc;
}
.button:hover {
  background: #ddd;
}
#fileElem {
  display: none;
}
```

Многие из этих стилей пока не вступили в игру, но это нормально. Основной момент сейчас это то, что поле `file` скрыто, а его подпись `label` стилизована так, чтобы выглядеть как кнопка, так люди поймут, что кликнув по нему вызовется диалог выбора файлов. Кроме того, мы следуем соглашению, согласно которому область куда следует бросить файл обозначается прерывистой линией.

## Добавляем функциональность Drag-and-Drop

Теперь можем перейти к сладкому: drag and drop. Давайте набрасаем скрипт внизу страницы или в отдельном файле, смотря как вам больше нравится. Первое, что нам понадобится это ссылка на область, куда предстоит тащить файл. Так мы сможем привязаться к событиям на ней:

```javascript
let dropArea = document.getElementById('drop-area')
```

Теперь давайте добавим несколько событий. Начнём с добавления обработчиков для всех событий, чтобы предотвратить поведение по-умолчанию и остановить всплытие выше необходимого:

```javascript
;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  dropArea.addEventListener(eventName, preventDefaults, false)
})

function preventDefaults (e) {
  e.preventDefault()
  e.stopPropagation()
}
```

Теперь давайте добавим индикатор, который позволит пользователям понять, что они действительно перетаскивали элементы над нужной областью, используем CSS для изменения цвета границы области для перетаскивания. Стили уже описаны выше для селектора `#drop-area.highlight`, так что давайте используем JS для добавления и удаления класса `highlight`, когда это необходимо.

```javascript
;['dragenter', 'dragover'].forEach(eventName => {
  dropArea.addEventListener(eventName, highlight, false)
})

;['dragleave', 'drop'].forEach(eventName => {
  dropArea.addEventListener(eventName, unhighlight, false)
})

function highlight(e) {
  dropArea.classList.add('highlight')
}

function unhighlight(e) {
  dropArea.classList.remove('highlight')
}
```

Мы использовали оба события `dragenter` и `dragover` для подсвечивания из-за причин, о которых я говорил ранее. Если вы начинаете перетаскивать непосредственно над `dropArea` и затем перешли на дочерний элемент, то сработает событие  `dragleave` и подсвечивание области пропадёт. Событие `dragover` сработает после событий `dragenter` и `dragleave`, так что подсветка вернётся обратно на `dropArea` до того как мы увидим как она пропала.

Мы также убираем подсветку когда перетаскиваемый элемент покидает обозначеную область и когда его бросают в неё.

Теперь всё что нам нужно сделать это выяснить что делать когда файлы будут брошены:

```javascript
dropArea.addEventListener('drop', handleDrop, false)

function handleDrop(e) {
  let dt = e.dataTransfer
  let files = dt.files

  handleFiles(files)
}
```

Код выше не приближает нас к завершению, но делает две важные вещи:

01. Демонстрирует как получить данные о файлах которые были брошены.
02. Приводит нас в то же место, что и поле `input` с типом `file` и обработчиком на событие `onchange`: `handleFiles`.

Держите в уме, что `files` это не массив, а `FileList`. Таким образом, при реализации `handleFiles`, нам нужно конвертировать `FileList` в массив, чтобы более легко было его итерировать:

```javascript
function handleFiles(files) {
  ([...files]).forEach(uploadFile)
}
```

Это было разочеровывающе. Давайте посмотрим в `uploadFile` for the *действительно* meaty stuff.

```javascript
function uploadFile(file) {
  let url = 'YOUR URL HERE'
  let formData = new FormData()

  formData.append('file', file)

  fetch(url, {
    method: 'POST',
    body: formData
  })
  .then(() => { /* Готово. Информируем пользователя */ })
  .catch(() => { /* Ошибка. Информируем пользователя */ })
}
```

Здесь мы используем `FormData`, встроенный браузерный API для создания форм с данными для отправки на сервер. Для этого мы используем `fetch` API, чтобы действительно отправить изображения на сервер. Убедитесь что вы изменили URL для работы с вашим сервером или сервисом, и с помощью `formData.append` можете добавить к форме любые дополнительные данные которые могут потребоваться для работы с вашим сервером. Как альтернатива, если вы хотите поддерживать Internet Explorer, вы можете захотеть использовать `XMLHttpRequest`, это значит, что ваш `uploadFile` будет выглядеть так:

```javascript
function uploadFile(file) {
  var url = 'YOUR URL HERE'
  var xhr = new XMLHttpRequest()
  var formData = new FormData()
  xhr.open('POST', url, true)

  xhr.addEventListener('readystatechange', function(e) {
    if (xhr.readyState == 4 && xhr.status == 200) {
      // Готово. Информируем пользователя
    }
    else if (xhr.readyState == 4 && xhr.status != 200) {
      // Ошибка. Информируем пользователя
    }
  })

  formData.append('file', file)
  xhr.send(formData)
}
```

В зависимости от настроек вашего сервера, вы можете проверять различные значения `status` отличные от `200`, но для наших нужд, это сработает.

## Дополнительные возможности

Это вся базовая функциональность, но часто требуется её расширить. Конкретно в этом руководстве, мы добавим панель предпросмотра, где будут показаны выбраные файлы, также добавим индикатор прогресса, который будет показывать пользователю статус загрузки. Итак, давайте начнём с предпросмотра изображений.

### Предпросмотр изображений

Есть несколько способов сделать это: вы можете ждать пока изображения загрузятся и запросить у сервера URL для картинок, но это означает что вам придется ждать и временами изображения могут быть довольно большими. Альтернатива — которую мы будет исследовать сегодня — это использовать [FileReader API](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) с данными файлов, которые мы получили из события `drop`. Это работает асинхронно, но вы можете использовать альтернативу [FileReaderSync](https://developer.mozilla.org/en-US/docs/Web/API/FileReaderSync), но мы можем попробовать прочитаться несколько больших файлов подряд, таким образом это может заблокировать поток выполнения на долгое время и по-настоящему испортить опыт взаимодействия пользователя. Чтож, давайте создадим `previewFile` функцию и посморим как это работает:

```javascript
function previewFile(file) {
  let reader = new FileReader()
  reader.readAsDataURL(file)
  reader.onloadend = function() {
    let img = document.createElement('img')
    img.src = reader.result
    document.getElementById('gallery').appendChild(img)
  }
}
```

Здесь мы создали `new FileReader` и вызвали метод `readAsDataURL` для объекта `File`. Как уже упоминалось, это работает асинхронно, поэтому нужно добавить обработчик события `onloadend` для обработки результата чтения файла. После этого используем base 64 URL адрес для атрибута `src` нового элемента `<img>` и добавляем его в элемент `gallery`. Есть только две вещи которые надо сделать чтобы всё было готово и работало: добавить элемент `gallery` и добавить вызов функции `previewFile`.

Во-первых, добавим HTML, который приведен ниже, сразу после закрывающего тега `form`:

```html
<div id="gallery"></div>
```

Ничего особенного, это просто `div`. Стили уже заданы для него и изображений в нем, так что больше здесь ничего делать не надо. Теперь изменим функцию `handleFiles` на следующую:

```javascript
function handleFiles(files) {
  files = [...files]
  files.forEach(uploadFile)
  files.forEach(previewFile)
}
```

Есть несколько способов, чтобы сделать это, такой как композиция, или простой колбек функции `forEach` в котором запускается `uploadFile` и `previewFile`, и это тоже работает. Таким образом, когда вы бросаете или выбираете несколько изображений, они будет показаны почти мгновенно ниже формы. Интересная мысль насчет этого — в некоторых приложениях — вы можете не захотеть реально загружать изображения на сервер, а вместо этого хранить ссылки на них в `localStorage` или в каком-нибудь другом кеше на стороне пользователя, чтобы приложение имело к ним доступ позже. Я лично не могу придумать хорошие сценарии использования этого, но я готов поспорить, что такие есть.

### Отслеживание прогресса

Если что-нибудь может занять некоторое время, индикатор прогресса может помочь пользователю понимать, что прогресс происходит и показывает как долго это будет выполняться. Добавить индикатора прогресса довольно легко, благодаря HTML5 тегу `progress`. Давайте начнём с добавления его в HTML код.

```html
<progress id="progress-bar" max=100 value=0></progress>
```

Вы можете шлёпнуть (_You can plop that_) его сразу после элемента `label` или между элементами `form` и `div` для предпросмотра изображений, как больше нравится. Для этого, вы можете добавить его куда захотите в пределах тега `body`. Стили для этого примера не добавлены, так что будет отрисован браузерный элемент по-умолчанию, которая пригодна. Теперь давайте работать над добавлением JavaScript. Для начала рассмотрим реализацию для `fetch` а затем покажем версию для `XMLHttpRequest`. Для начала нам понадобится пара новых переменных в верхней части скрипта:

```javascript
let filesDone = 0
let filesToDo = 0
let progressBar = document.getElementById('progress-bar')
```

При использовании `fetch` мы только можем определить когда загрузка завершена, так что единственная информация, которую мы отслеживаем, - это то сколько файлов выбрано для загрузки (переменная `filesToDo`) и количество уже загруженных файлов (переменная `filesDone`). Мы также храним ссылку на элемент `#progress-bar`, чтобы мы могли быстро обновлять его. Теперь давайте создадим пару функций для управления прогрессом:

```javascript
function initializeProgress(numfiles) {
  progressBar.value = 0
  filesDone = 0
  filesToDo = numfiles
}

function progressDone() {
  filesDone++
  progressBar.value = filesDone / filesToDo * 100
}
```

Когда мы начинаем загрузку, вызовем  функцию `initializeProgress` для сброса состояния индикатора. Затем, с каждой выполненой загрузкой, мы вызываем функцию `progressDone` для увеличения числа загруженых файлов на единицу и обновления индикатора для демонстрации прогресса. Итак, добавим вызовы этих функций, обновив пару старых:

```javascript
function handleFiles(files) {
  files = [...files]
  initializeProgress(files.length) // <- Add this line
  files.forEach(uploadFile)
  files.forEach(previewFile)
}

function uploadFile(file) {
  let url = 'YOUR URL HERE'
  let formData = new FormData()

  formData.append('file', file)

  fetch(url, {
    method: 'POST',
    body: formData
  })
  .then(progressDone) // <- Добавим `progressDone` вызов здесь
  .catch(() => { /* Ошибка. Сообщаем пользователю */ })
}
```

И на этом всё. Теперь посмотрим как выглядит реализация с `XMLHttpRequest`. Мы могли бы сделать просто быстроеобновление в `uploadFile`, но `XMLHttpRequest` фактически дает нам больше функциональности чем `fetch`, а именно мы способны добавить обработчик события для прогресса загрузки на каждом запросе, который будет переодически давать информацию о том, каков текущий прогресс загрузки. Поэтому, нам нужно отслеживать процентную готовность каждого запроса вместо количества выполненых запросов. Итак, давайте начнём с замены объявлений переменных `filesDone` и `filesToDo` на следующий код:

```javascript
let uploadProgress = []
```

Тогда нам нужно обносить и наши функции. Переименуем `progressDone` в `updateProgress` и изменим её код как показано ниже:

```javascript
function initializeProgress(numFiles) {
  progressBar.value = 0
  uploadProgress = []

  for(let i = numFiles; i > 0; i--) {
    uploadProgress.push(0)
  }
}

function updateProgress(fileNumber, percent) {
  uploadProgress[fileNumber] = percent
  let total = uploadProgress.reduce((tot, curr) => tot + curr, 0) / uploadProgress.length
  progressBar.value = total
}
```

Теперь `initializeProgress` инициализирует массив с длиной равной `numFiles` который заполнен нулями, означающими что каждый файл загружен на 0%. В `updateProgress` какое из изображений обновляет свой прогресс и изменяем значение элемента с нужным индексом на предоставленный `percent`. Затем мы вычисляем общий процент прогресса как среднее среди всех процентов и обновлеем индикатор прогресса, чтобы отобразить вычисленное значение. Мы по-прежнему вызываем `initializeProgress` в `handleFiles` также как делали это в примере с  `fetch`, так что теперь всё что нам нужно, это обновить `uploadFile` добавив вызов `updateProgress`.

```javascript
function uploadFile(file, i) { // <- Добавили параметр `i`
  var url = 'YOUR URL HERE'
  var xhr = new XMLHttpRequest()
  var formData = new FormData()
  xhr.open('POST', url, true)

  // Добавили следующие слушатели
  xhr.upload.addEventListener("progress", function(e) {
    updateProgress(i, (e.loaded * 100.0 / e.total) || 100)
  })

  xhr.addEventListener('readystatechange', function(e) {
    if (xhr.readyState == 4 && xhr.status == 200) {
      // Готово. Сообщаем пользователю
    }
    else if (xhr.readyState == 4 && xhr.status != 200) {
      // Ошибка. Сообщаем пользователю
    }
  })

  formData.append('file', file)
  xhr.send(formData)
}
```

Первое, что нужно отметить, это то, что мы добавили параметр `i`. Это индекс файла в списке файлов. Нам не нужно обновлять `handleFiles` для передачи этого параметра, потому что он использует `forEach`, который уже передаёт индекс элемента вторым параметром в колбек. Мы также добавили слушатель на событие `progress` в `xhr.upload`, чтобы мочь вызвать `updateProgress` со значением прогресса. Объект события (`e` в нашем коде) имеет два куска информации о нём: `loaded` который содержит число байт, которые уже загружены, и `total` который содержит число байт в файле в общей сложности.

Часть `|| 100` нужна потому, что иногда при возникновении ошибки, `e.loaded` и `e.total` будут равны нулю, что означает, что вычисления дадут `NaN`, таким образом `100` используется вместо отчета о выполнении загрузки. Вы можете также использовать `0`. В любом случае, ошибки будут отображаться в обработчике события `readystatechange`, так что вы можете сообщить о нихпользователю. Это сделано просто для предотвращения исключений, связанных с попытками вычислений с `NaN`.

## Заключение

Это завершающая часть. Вы получили страницу, на которой вы можете загружать изображения с помощью drag and drop, предварительный просмотр изображений, загружаемый немедленно, и просмотр прогресса загрузки с помощью индикатора програсса. Вы можете посмотреть конечную версию (с использованием `XMLHttpRequest`) в действии на [CodePen](https://codepen.io/joezimjs/pen/yPWQbd), но помните, что сервис в который я загружаю файлы имеет ограничения, так что если много людей будут его пробовать, он может сломаться на некоторое время.
