# 3+ года Ember, 6 месяцев React

>TL;DR: Фреймворк это всегда хорошо, особенно для разработки быстрорастущего продукта или когда нужно поддерживать код в непостоянной команде

Я все еще помню мой первый опыт работы с Ember: это было немногим больше 3-х лет назад, когда Ember был еще версии 1.5.7. Требованием клиента было "чтобы работало оффлайн" и похоже на магазин на Rails, поэтому казалось правильным выбрать фреймворк, который следует соглашениям по конфигурации - основной философией Rails. На тот момент я только видел ember-cli (интефрейс командной строки для Ember), который был нужен для помощи при настройке приложения на Ember и имел вдохновленные Rails генераторы файлов, типа `ember generate route post`. Мне никогда не нравились генераторы в Rails, поэтому и здесь я их не использовал, но все же ember-cli позволял сделать первоначальную настройку с легкостью: без ember-cli вам нужно подключать и настраивать скрипты и все остальное самостоятельно, что напоминает мне front-end разработку прошлого десятилетия. Я ясно помню, как я сомневался сделал ли я правильный выбор использовать ember-cli для работы с Ember.

После прочтения всей документации "фреймворка для создания амбициозных веб-приложений" я сел и стал создавать мои первые роуты и шаблоны, следуя спецификации дизайна. В тот момент Ember был магическим и ужасным одновременно. Магическим потому, что я раньше никогда не видел ничего подобного, это был мой первый опыт с *реактивным программированием* и честно говоря, мне потребовалось не мало времени, чтобы понять, что множество классических паттернов разработки не всегда работают для реактивного программирования. Также ember-cli предоставляет поддержку ES6 из коробки, что делает написание кода на JavaScript удовольствием. С другой стороны, работа с тем, что на тот момент называлось handlebars была ужасна и я как сейчас помню уродливость `bind-attr`, который нужно было использовать, чтобы связать свойство компоненты или контроллера (да, тогда контроллеры много значили!) с html тэгом. Да, работать с handlebars было иногда неприятно, но на дворе был 2014, когда React еще не был даже аннонсирован и единственная реальная альтернатива, полноценный фронтенд фреймворк, был AngularJS.

Прошло больше 3-х лет и мы в Kallegorna сделали не мало проектов на Ember и я лично создал множество приложений на стороне от маленьких до огромных. Все это время мне нравился Ember потому он делал меня супер производительным: если вы попросите меня создать прототип для клиента на Ember + Rails или на чистом Rails, я определенно выберу первый вариант. Мне даже не нужно API, я просто настрою адаптер для local storage, спроектирую модели как мне нужно, добавлю немного фабрик для тестовых данных и начню писать прототип. А когда мы закончим с API, мы просто переключим адаптер на тот, который соотвествует API.

Когда ты по настоящему работаешь с фреймфорками это позволяет обновлять DOM так просто, что совсем не хочется возвращаться к традиционному подходу, вроде Rails Views. Не будет преувелечением сказать, что Ember изменил мой образ мышления, особенно относительно сложных DOM элементов вроде форм. И если handlebars был примитивным, HTMLBars, появившийся в Ember 2.0 весьма мощный, по крайней мере достаточно мощный, что вам не нужно чего-то большего. Но что мне особенно нравится в Ember, это то, что ты имеешь дело с фреймворком и это уже дает множество преимуществ, например система аддонов. Может потому что я изначально не фронтенд разработчик, а может я просто не люблю изобретать велосипед, но то что я могу просто установить аддон и сразу же использовать его в шаблонах - супер продуктивно.

## React приключение

6 месяцев назад, мне сообщили, что я буду работать с клиентом, который хочет создать новое фронтенд приложение на React. Честно говоря, я был очень счастлив узнав это. *Наконец* я смогу попробовать эту штуку под названием React и его экосистему. Все вокруг говорили про React, его паттерн data-down-actions-up (данные вниз, события наверх) был настолько революционным, что даже Ember адоптировал его ( = добавил лучшую поддержку) и я не совру, сказав, что паттерны React сильно повлияли на Ember сообщество, взяв вещи, которые вероятно имели наибольший смысл. Я был очень счастлив.

В первый день работы с React я сел и прочитал всю официальную документацию. После 3 лет опыта с Ember, я не только понял React за несколько часов, но также осознал почему вещи работают так, как работают и общие паттерны. В сущности я бы сказал, что [React-компоненты](https://reactjs.org/docs/react-component.html) не сильно отличаются от [Ember-компонент](https://emberjs.com/api/ember/2.15.3/classes/Ember.Component). Все было круто и очень вдохновляло.

Но к сожалению, со временем я стал осозновать, что React и его экосистема упускает некоторые ключевые вещи, которые вы могли бы ожидать от обычных фронтенд феймворков типа EmberJS, AngularJS, VueJS и остальных.

### Webpack сложный, хотя и стал стандартом де-факто

В течении 6 месяцев я ни разу не прикасался к Webpack. Хотя я *пытался* понять его с помощью документации и туториалов, я так на самом деле ничего не понял. Мне кажется, что Webpack стал стандартом де-факто во фронтенд разработке, но у меня никогда не было подобных проблем с Ember. Я думаю ближайшим аналогом Webpack в Ember является Broccoli в комбинации с ember-cli. Оба инструмента очень легко понять.

С Ember вы можете создать и в буквальном смысле развернуть проект за 5 минут, например с помощью [Surge](https://surge.sh/) (или даже использую серверный рендеринг с [fastboot](https://github.com/ember-fastboot/ember-cli-fastboot) на [Heroku](https://www.heroku.com/)), и я думаю это большое преимущество. Что касается Webpack, то я слышал много историй, как разработчики тратили от 1 до 3 дней чтобы настроить его правильно, что очень расстраивает меня :(

### React хорош, но он только view

На случай, если вы еще это не поняли, React сам по себе это просто прослойка для view. Если вам нужно многостраничное приложение, вам понадобится по крайней мере библиотека для роутинга, например [react-router](https://github.com/ReactTraining/react-router), а также что-то для управления состоянием вроде [react-redux](https://github.com/reactjs/react-redux).

Хотя это может звучать как хорошая вещь для многих разработчиков, которые не одобряют фреймворки, помните, что *делая ваш основной код зависимым от множества библиотек*, которые вам нужны, вам придется терпеть их особенности или решения мейнтейнеров (например несовместимость API в в следующем релизе...). Также стоит учитывать, что библиотеки разрабатываются асинхронно друг от друга (и от React) делая поддержку кода с годами все сложнее.

### react-route не очень хорошая библиотека
[React-router](https://github.com/ReactTraining/react-router) стандартная библиотека для React и неожиданно не самая лучшая. Иногда 
[react-mini-router](https://github.com/larrymyers/react-mini-router) или даже [reqct-spoon](https://github.com/iyobo/react-spoon), который имеет только 5 звезд на GitHub на момент написания этой статьи, может быть более мудрым выбором, чем react-router.

#### Обратная несовместимость в каждой версии

Мы использовали react-router V4 и догодайтесь что значит V4: каждая версия переписывалась заново, не сохраняя обратной совместимости с предыдущими версиями. Разве это хорошо?

Для сравнения Ember роутер едва ли изменился за последние три года. Вот зачем нужен движимый RFC путь разработки библиотек и вероятно даже всего фреймворка. Возможно, за исключением небольших правок объявлений роутов в файле router.js, обновление займет максимум полчаса. И все изменения имеют предупреждения об устаревании (deprecation warnings) с информацией о том, как обновиться со множеств предыдущих версий до того, как финальные изменения будут приняты в библиотеку и сломают обратную совместимость.

#### Нет именованных роутов

Что еще хуже, у вас не может быть именованных роутов, потому что это считается [анти-паттерном](https://github.com/ReactTraining/react-router/issues/1514#issuecomment-122011215). Я здесь единственный, кто считает, что именованные роуты необходимы современному веб-приложению?
Вот две причины:
1. Я понимаю, что большинство сайтов написано на английском, но случается, что люди разрабатывают сайты на своих родных языках тоже и URL тут не будет исключением. Я действительно должен писать на китайском каждый раз, когда мне нужно сделать редирект/ссылку на роут?
2. Разве не лучше иметь одно место, где вы можете объявить все ваши роуты? С react-router, кажется роуты разбросаны по всему коду и если вам придется разбираться в существующем приложении на React, вам придется открыть не мало файлов прежде чем вы поймете, что происходит.

Когда вы приходите в проект на Ember, первая вещь на которую вы смотрите это `router.js` файл, где объявлены все роуты приложения. Глядя только на этот файл уже можно понять как устроено приложение, понять где находится нужный файл и сделать необходимые изменения.

!!!!

#### Роуты !== компоненты

Одна вещь, которая мне не нравится в React экосистеме это подход, что все может быть компонентой. Мне не кажется, что эта логика всегда работает и мне нравится подход Ember к этому. Вам определенно нужно, чтобы Роуты (можете называть их компонентами страниц) заметно отличались от обычных компонент. У роута должны быть отличные от компонент хуки, обрабатывающие url-параметры, загрузочные/ошибочные состояния, редиректы, авторизацию роута, различные жизненные циклы, определяющие, что приходит первым, а что последним, когда мы входим в роут и много других вещей. И со всем этим нам должны помогать библиотека или фреймворк. В противном случае мы должны сами придумывать как сделать все это и я не верю, что все разработчики способны написать чистый, поддерживаемый, тестируемый и масштабируемый код, чтобы сделать это.

React компонента не может всегда выполнить роль обработчика роута/страницы.

#### Сложности с вещами, который должны быть просты

Как сделать редирект после Redux события? [Ответ](https://stackoverflow.com/a/42124328/1291118) на Stack Overflow напоминает мне о преимуществах полноценного фреймворка.

В Ember это всегда было просто. Вы просто шлете роут-событие из компоненты вверх до роута, который ловит его и делает задуманный редирект. И все это [одна строка кода](https://www.emberjs.com/api/ember/2.15/classes/Ember.Route/methods/transitionTo?anchor=transitionTo), вместе с параметрами события.

### JXS или Handlebars, выбор ваш

Работая с Ember handlebars, а именно с HTMLBars с версии 2.0, шаблоны JSX выглядели немного странно для меня первый месяц. Потом я привык.

Однако, если вы спросите меня сейчас, Handlebars или JSX, я скажу, что меня устраивают оба, но если придется выбирать, то я выберу Handlebars. Одна из причин это возможность копировать/вставлять чистый HTML и он просто будет работать. Еще еще одна причина, это более легкое понимание того, что компонент делает, благодаря DSL дизайну, в то время как JSX выглядит как грязный хак, но это возможно только мое мнение. Я бы также предположил, что фронтедеру/дизайнеру будет намного легче разобраться в `.hbs` файле, чем в JSX (который часто приводил меня к спагетти коду), но опять же, я могу ошибаться.

### react-redux клевый паттерн

С самого начала мы понимали, что далеко не уедем на одном лишь React. У нас уже был React-Router для роутинга, но нам нужно было что-то для управления со стороны, вроде сервиса в Ember, потому что вы просто не можете прокидывать свойства по всем компонентам вниз. Это будет просто не поддерживаемо. [React-Redux](https://github.com/reactjs/react-redux) был очевидным выбором: Redux очень популярен для работы с состоянием в React приложении, мы слышали о нем везде. На самом деле, даже работая с Ember я слышал очень много о Redux, и о том, что он стал в какой-то степени революционным подходом в работе с состоянием .

Эта библиотека действительно помогла нам разгрузить компоненты (они стали функциональными) и мне просто нравится работать с ней. Паттерн был всегда одинаковым: 
правильная инициализация состояния, добавление события, добавление редьюсера, если нужно, и использование событий в компоненте. Некоторые вещи все же давались мне с трудом с Redux, но в целом он мне очень понравился.

Единственная проблема, которую я заметил, это то, что если ты уже выбрал react-redux, ты замкнут в этом паттерне. Сделать, например, половину приложения используя react-redux, а другую mobx будет чрезвычайно сложно, но я не уверен смог бы фреймворк решить эту проблему.

По опыту могу сказать, что вам редко понадобится глобальное состояние в Ember. Вместо это вы будете использовать маленькие сервисы (которые по сути состовляют ваше глобальное состояние). Я и правда думаю, что Ember дает вам так много инструментов, что иметь глобальное состояние становится избыточным. Тем не менее, я совсем не противник этого и буду рад попробовать [ember-redux](https://github.com/ember-redux/ember-redux).

### 