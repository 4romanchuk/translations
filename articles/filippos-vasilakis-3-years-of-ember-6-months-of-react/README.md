# 3+ года Ember, 6 месяцев React

>TL;DR: Фреймворк это всегда хорошо, особенно для разработки быстрорастущего продукта или когда нужно поддерживать код в непостоянной команде

Я все еще помню мой первый опыт работы с Ember: это было немногим больше 3-х лет назад, когда Ember был еще версии 1.5.7. Требованием клиента было "чтобы работало оффлайн" и похоже на магазин на Rails, поэтому казалось правильным выбрать фреймворк, который следует соглашениям по конфигурации - основной философией Rails. На тот момент я только видел ember-cli (интефрейс командной строки для Ember), который был нужен для помощи при настройке приложения на Ember и имел вдохновленные Rails генераторы файлов, типа `ember generate route post`. Мне никогда не нравились генераторы в Rails, поэтому и здесь я их не использовал, но все же ember-cli позволял сделать первоначальную настройку с легкостью: без ember-cli вам нужно подключать и настраивать скрипты и все остальное самостоятельно, что напоминает мне front-end разработку прошлого десятилетия. Я ясно помню, как я сомневался сделал ли я правильный выбор использовать ember-cli для работы с Ember.

После прочтения всей документации "фреймворка для создания амбициозных веб-приложений" я сел и стал создавать мои первые роуты и шаблоны, следуя спецификации дизайна. В тот момент Ember был магическим и ужасным одновременно. Магическим потому, что я раньше никогда не видел ничего подобного, это был мой первый опыт с *реактивным программированием* и честно говоря, мне потребовалось не мало времени, чтобы понять, что множество классических паттернов разработки не всегда работают для реактивного программирования. Также ember-cli предоставляет поддержку ES6 из коробки, что делает написание кода на JavaScript удовольствием. С другой стороны, работа с тем, что на тот момент называлось handlebars была ужасна и я как сейчас помню уродливость `bind-attr`, который нужно было использовать, чтобы связать свойство компоненты или контроллера (да, тогда контроллеры много значили!) с html тэгом. Да, работать с handlebars было иногда неприятно, но на дворе был 2014, когда React еще не был даже аннонсирован и единственная реальная альтернатива, полноценный фронтенд фреймворк, был AngularJS.

Прошло больше 3-х лет и мы в Kallegorna сделали не мало проектов на Ember и я лично создал множество приложений на стороне от маленьких до огромных. Все это время мне нравился Ember потому он делал меня супер производительным: если вы попросите меня создать прототип для клиента на Ember + Rails или на чистом Rails, я определенно выберу первый вариант. Мне даже не нужно API, я просто настрою адаптер для local storage, спроектирую модели как мне нужно, добавлю немного фабрик для тестовых данных и начню писать прототип. А когда мы закончим с API, мы просто переключим адаптер на тот, который соотвествует API.

Когда ты по настоящему работаешь с фреймфорками это позволяет обновлять DOM так просто, что совсем не хочется возвращаться к традиционному подходу, вроде Rails Views. Не будет преувелечением сказать, что Ember изменил мой образ мышления, особенно относительно сложных DOM элементов вроде форм. И если handlebars был примитивным, HTMLBars, появившийся в Ember 2.0 весьма мощный, по крайней мере достаточно мощный, что вам не нужно чего-то большего. Но что мне особенно нравится в Ember, это то, что ты имеешь дело с фреймворком и это уже дает множество преимуществ, например система аддонов. Может потому что я изначально не фронтенд разработчик, а может я просто не люблю изобретать велосипед, но то что я могу просто установить аддон и сразу же использовать его в шаблонах - супер продуктивно.

## React приключение

6 месяцев назад, мне сообщили, что я буду работать с клиентом, который хочет создать новое фронтенд приложение на React. Честно говоря, я был очень счастлив узнав это. *Наконец* я смогу попробовать эту штуку под названием React и его экосистему. Все вокруг говорили про React, его паттерн data-down-actions-up (данные вниз, события наверх) был настолько революционным, что даже Ember адоптировал его ( = добавил лучшую поддержку) и я не совру, сказав, что паттерны React сильно повлияли на Ember сообщество, взяв вещи, которые вероятно имели наибольший смысл. Я был очень счастлив.

В первый день работы с React я сел и прочитал всю официальную документацию. После 3 лет опыта с Ember, я не только понял React за несколько часов, но также осознал почему вещи работают так, как работают и общие паттерны. В сущности я бы сказал, что [React-компоненты](https://reactjs.org/docs/react-component.html) не сильно отличаются от [Ember-компонент](https://emberjs.com/api/ember/2.15.3/classes/Ember.Component). Все было круто и очень вдохновляло.

Но к сожалению, со временем я стал осозновать, что React и его экосистема упускает некоторые ключевые вещи, которые вы могли бы ожидать от обычных фронтенд феймворков типа EmberJS, AngularJS, VueJS и остальных.

### Webpack сложный, хотя и стал стандартом де-факто

В течении 6 месяцев я ни разу не прикасался к Webpack. Хотя я *пытался* понять его с помощью документации и туториалов, я так на самом деле ничего не понял. Мне кажется, что Webpack стал стандартом де-факто во фронтенд разработке, но у меня никогда не было подобных проблем с Ember. Я думаю ближайшим аналогом Webpack в Ember является Broccoli в комбинации с ember-cli. Оба инструмента очень легко понять.

С Ember вы можете создать и в буквальном смысле развернуть проект за 5 минут, например с помощью [Surge](https://surge.sh/) (или даже использую серверный рендеринг с [fastboot](https://github.com/ember-fastboot/ember-cli-fastboot) на [Heroku](https://www.heroku.com/)), и я думаю это большое преимущество. Что касается Webpack, то я слышал много историй, как разработчики тратили от 1 до 3 дней чтобы настроить его правильно, что очень расстраивает меня :(

### React хорош, но он только view

На случай, если вы еще это не поняли, React сам по себе это просто прослойка для view. Если вам нужно многостраничное приложение, вам понадобится по крайней мере библиотека для роутинга, например [react-router](https://github.com/ReactTraining/react-router), а также что-то для управления состоянием вроде [react-redux](https://github.com/reactjs/react-redux).

Хотя это может звучать как хорошая вещь для многих разработчиков, которые не одобряют фреймворки, помните, что *делая ваш основной код зависимым от множества библиотек*, которые вам нужны, вам придется терпеть их особенности или решения мейнтейнеров (например несовместимость API в в следующем релизе...). Также стоит учитывать, что библиотеки разрабатываются асинхронно друг от друга (и от React) делая поддержку кода с годами все сложнее.

### react-route не очень хорошая библиотека
[React-router](https://github.com/ReactTraining/react-router) стандартная библиотека для React и неожиданно не самая лучшая. Иногда 
[react-mini-router](https://github.com/larrymyers/react-mini-router) или даже [reqct-spoon](https://github.com/iyobo/react-spoon), который имеет только 5 звезд на GitHub на момент написания этой статьи, может быть более мудрым выбором, чем react-router.

#### Обратная несовместимость в каждой версии

Мы использовали react-router V4 и догодайтесь что значит V4: каждая версия переписывалась заново, не сохраняя обратной совместимости с предыдущими версиями. Разве это хорошо?

Для сравнения Ember роутер едва ли изменился за последние три года. Вот зачем нужен движимый RFC путь разработки библиотек и вероятно даже всего фреймворка. Возможно, за исключением небольших правок объявлений роутов в файле router.js, обновление займет максимум полчаса. И все изменения имеют предупреждения об устаревании (deprecation warnings) с информацией о том, как обновиться со множеств предыдущих версий до того, как финальные изменения будут приняты в библиотеку и сломают обратную совместимость.

#### Нет именованных роутов

Что еще хуже, у вас не может быть именованных роутов, потому что это считается [анти-паттерном](https://github.com/ReactTraining/react-router/issues/1514#issuecomment-122011215). Я здесь единственный, кто считает, что именованные роуты необходимы современному веб-приложению?
Вот две причины:
1. Я понимаю, что большинство сайтов написано на английском, но случается, что люди разрабатывают сайты на своих родных языках тоже и URL тут не будет исключением. Я действительно должен писать на китайском каждый раз, когда мне нужно сделать редирект/ссылку на роут?
2. Разве не лучше иметь одно место, где вы можете объявить все ваши роуты? С react-router, кажется роуты разбросаны по всему коду и если вам придется разбираться в существующем приложении на React, вам придется открыть не мало файлов прежде чем вы поймете, что происходит.

Когда вы приходите в проект на Ember, первая вещь на которую вы смотрите это `router.js` файл, где объявлены все роуты приложения. Глядя только на этот файл уже можно понять как устроено приложение, понять где находится нужный файл и сделать необходимые изменения.

!!!!

#### Роуты !== компоненты

Одна вещь, которая мне не нравится в React экосистеме это подход, что все может быть компонентой. Мне не кажется, что эта логика всегда работает и мне нравится подход Ember к этому. Вам определенно нужно, чтобы Роуты (можете называть их компонентами страниц) заметно отличались от обычных компонент. У роута должны быть отличные от компонент хуки, обрабатывающие url-параметры, загрузочные/ошибочные состояния, редиректы, авторизацию роута, различные жизненные циклы, определяющие, что приходит первым, а что последним, когда мы входим в роут и много других вещей. И со всем этим нам должны помогать библиотека или фреймворк. В противном случае мы должны сами придумывать как сделать все это и я не верю, что все разработчики способны написать чистый, поддерживаемый, тестируемый и масштабируемый код, чтобы сделать это.

React компонента не может всегда выполнить роль обработчика роута/страницы.

#### Сложности с вещами, который должны быть просты

Как сделать редирект после Redux события? [Ответ](https://stackoverflow.com/a/42124328/1291118) на Stack Overflow напоминает мне о преимуществах полноценного фреймворка.

В Ember это всегда было просто. Вы просто шлете роут-событие из компоненты вверх до роута, который ловит его и делает задуманный редирект. И все это [одна строка кода](https://www.emberjs.com/api/ember/2.15/classes/Ember.Route/methods/transitionTo?anchor=transitionTo), вместе с параметрами события.

### JXS или Handlebars, выбор ваш

Работая с Ember handlebars, а именно с HTMLBars с версии 2.0, шаблоны JSX выглядели немного странно для меня первый месяц. Потом я привык.

Однако, если вы спросите меня сейчас, Handlebars или JSX, я скажу, что меня устраивают оба, но если придется выбирать, то я выберу Handlebars. Одна из причин это возможность копировать/вставлять чистый HTML и он просто будет работать. Еще еще одна причина, это более легкое понимание того, что компонент делает, благодаря DSL дизайну, в то время как JSX выглядит как грязный хак, но это возможно только мое мнение. Я бы также предположил, что фронтедеру/дизайнеру будет намного легче разобраться в `.hbs` файле, чем в JSX (который часто приводил меня к спагетти коду), но опять же, я могу ошибаться.

### react-redux клевый паттерн

С самого начала мы понимали, что далеко не уедем на одном лишь React. У нас уже был React-Router для роутинга, но нам нужно было что-то для управления со стороны, вроде сервиса в Ember, потому что вы просто не можете прокидывать свойства по всем компонентам вниз. Это будет просто не поддерживаемо. [React-Redux](https://github.com/reactjs/react-redux) был очевидным выбором: Redux очень популярен для работы с состоянием в React приложении, мы слышали о нем везде. На самом деле, даже работая с Ember я слышал очень много о Redux, и о том, что он стал в какой-то степени революционным подходом в работе с состоянием .

Эта библиотека действительно помогла нам разгрузить компоненты (они стали функциональными) и мне просто нравится работать с ней. Паттерн был всегда одинаковым: 
правильная инициализация состояния, добавление события, добавление редьюсера, если нужно, и использование событий в компоненте. Некоторые вещи все же давались мне с трудом с Redux, но в целом он мне очень понравился.

Единственная проблема, которую я заметил, это то, что если ты уже выбрал react-redux, ты замкнут в этом паттерне. Сделать, например, половину приложения используя react-redux, а другую mobx будет чрезвычайно сложно, но я не уверен смог бы фреймворк решить эту проблему.

По опыту могу сказать, что вам редко понадобится глобальное состояние в Ember. Вместо это вы будете использовать маленькие сервисы (которые по сути состовляют ваше глобальное состояние). Я и правда думаю, что Ember дает вам так много инструментов, что иметь глобальное состояние становится избыточным. Тем не менее, я совсем не противник этого и буду рад попробовать [ember-redux](https://github.com/ember-redux/ember-redux).

### Необходима инфраструктура запуска приложения

Выболнить какой-либо важный код до старта приложения не так просто в React экосистеме. Когда мне это действительно понадобилось, мне пришлось рендерить пустоту из корневой компоненты, делать там, что мне необходимо и затем обновлять все состояние, что приводит к ре-рендерингу всего приложения с примененными изменениями.

В фреймворке, как Ember, это заложено дизайном. Фактически у вас есть два вида инициализации: инициализация приложения и инициализация экземпляра. Первая выполняется во время сборки приложения, что по существу дает гибкость иметь место, где можно добавить свои прототипы, вставить какой-то код и прочее. Вторая запускается во время старта приложения, помогая сделать такие вещи, как A/B тестирование в зависимости от настроек пользователя.

И вновь, в экосистеме React *отсутствие фреймфорка заставляет тратить время для решения тривиальных задач*, вместо того, чтобы сосредоточится на продукте.

### Смешение функциональных и ОО паттернов

Я не утверждаю, что это плохо, но для некоторых разработчиков нет так много времени, чтобы погружаться во все эти вещи разом (реактивное программирвоание, React, react-redux, react-router, высокоуровневые компоненты, JSX и прочее) в новом проекте, это может быть слишком.

Я слышал, что MobX ближе к ОО принципам и больше подходит, если вы не знакомы с функциональным программированием, так что я его возможно попробую.

### Нет ничего похожего на ember-date :(

Я бы хотел, чтобы ember-data была доступна как отдельная библиотека. Это штука просто магия и я действительно так считаю! Например, если вы хотите начать разработку своего приложения, но ребята с бэкенда еще не началаи делать API, вы можете подключить locale storage или session storage адаптер и начать разрабатывать с ним (вместе с моками данных из [ember-date-factory-guy](https://github.com/danielspaniel/ember-data-factory-guy)). Затем, когда бэкенд API будет готово, вам просто нужно заменить аддон, который вы использовали, на [RESTAdapter](https://www.emberjs.com/api/ember-data/2.16/classes/DS.RESTAdapter) или [JSONAPIAdapter](https://www.emberjs.com/api/ember-data/2.16/classes/DS.JSONAPIAdapter). Интерфейс, который будет использовать приложение останетсья тем же.

Конечно, вы можете сделать это и с React, но я сомневаюсь, что все разработчики способны создать чистые, поддерживаемые и тестирумые интерфейсы для создания такой архитектуры, при которой легко можно будет переключаться между разными адаптерами/сериалайзерами.

Также, даже если API с который вы общаетесь не сделано полностью по REST, ember-data дает гибкость настроить общение с API с помощью ваших собственных сериалайзеров/десериалайзеров или даже перенастроить адаптер под ваши нужды, сохраняя при этом прежний интерфейс для приложения. Если API с которым вы работаете консистентно в ответах, то этот процесс настолько прост, что вам может потребоваться переопределить лишь пару методов.

Жаль, если эта библиотека останется только внутри Ember и не будет выделена, как отдельная библиотека.

### Чувак, ты говоришь, что Ember идеален?

*Нет.*

Ember далек от совершенства. По факту у Ember было много проблем, когда я впервые стал исопльзовать его. Но со временем он решает их, прислушываясь к сообществу, а также в связи с тем фактом, что в рамках фреймворка намного проще развиваться, не разочаровывая пользователей.

В любом случае, вот несколько вещей, который каждый разработчик, по моему мнению, должен учитывать, когда начинает новый проект:

#### Фреймворк это платформа

Фреймворк предоставляет вам самое полезное API, которые вы можете использовать, когда вам нужно, без необходимости привязки к определенному паттерну и эта причина, по который мы должны смотреть в сторону фреймворков, вроде EmberJS/Angular/VueJS. Это платформа. Скучная платформа, скажете вы, но подобная платформа с хорошими примитивами и инфраструктурой все вам нужно для создания чего-угодно на ее базе. При этом фокусируясь на продукт и не переизобретая колеса каждый раз.

### Производительность не так важна, важен результат

Существует сумасшедшая гонка за лучшей производительностью, но нужна ли она нам так сильно? Я не продался идеи, что все приложения должны иметь идеальную производительность, используя библиотеки типа [InfernoJS](https://github.com/infernojs/inferno). На самом деле, я думаю, намного важнее доставлять фичи и поддерживать кодовую базу, которую в тоже время можно легко изменить, если изменяться требования.

Относительно производительности Ember я думаю что сейчас она достаточно хороша для 95% фронтенд приложений и учитывая, что LinkedIn [постоянно улучшает](https://www.linkedin.com/pulse/glimmers-optimizing-compiler-chad-hietala/) GlimmerJS, одновременно уменьшая его размер, будущее для Ember выглядит оптимистично. Но если вам нужно больше производительности^ вы всегда можете попробовать новые [Glimmer компоненты](https://glimmerjs.com/) или просто рендерить React внутри Ember. (А если вам нужно что-то экстримально быстрое, то наверняка вы уже эксперт во фронтенд разработке и без проблем справитесь с всей React экосистемой)

### Хорошая документация

Документация один из важнейших аспектов для фреймворка или библиотеки. Она дает возможность пользователям использовать платформу по максимуму и конечно хорошая документация мотивирует проверять сначала ее, прежде чем искать ответы в google.

По моему личному мнению, у Ember одна из самых лучших документаций, который я когда-либо видел у фреймворка или библиотеки и она помогала мне бесчислееное количество раз, даже с при поиске фич, которые не были хорошо известны.

### Стабильность

Стабильность еще один ключевой аспект библиотеки или фреймворка. А также взаимодействие с пользователями также очень важно (Я смотрю на тебя Angular). Стабильность гарантирует, что вы не будете тратить деньги/время, чтобы поддерживать вашу кодовую базу в актуальном состоянии и я думаю, это то, что часто упускается из виду под воздействием хайпа.

Ember всегда был очень стабильным, особенно после версии 2.0: мы обновились до HTMLBars без единой ошибки, мы обновились до Glimmer VM с тремя предупреждениями об устаревшем API. Мы обновляли Ember очень много раз, тратя на это очень мало времени. Для Ember *стабильность часть основых принципов*. Так что даже когда появилась [новая структура папок](https://github.com/ember-cli/ember-cli/issues/6332) (критические изменения!), заблаговременно был выпушен [инструмент командной строки](https://github.com/rwjblue/ember-module-migrator), которой автоматически конвертировал ваш устаревший проект в новый. Разве это не здорово?

### Прислушивается к своим пользователям

Но мне больше всего нравится в Ember и я думаю каждый фреймворк или библиотека должны следовать этому - развитие фреймфорка пользователями, а не ковбоем, который считает, что он/она может переписать всю библиотеку целиком с "необходимыми" критическими изменениями.

Ember следует процессу [RFC](https://en.wikipedia.org/wiki/Request_for_Comments) для новых фич и изменений в котором любой может принять участие: вы можете создать [свой RFC документ](https://github.com/emberjs/rfcs) описывающий новое API, его детальный дизайн (детальная реализация может быть предоставлена позже), зачем это нужно, насколько это совместимо с текущим API или нужны какие-то критические изменения и прочее. Затем, каждый может учавствовать в обсуждении и первоначальный документ преобразовывается в финальный через взаимодействие и вклад всего сообщества. И когда этот документ будет принят, тогда основная команда (core team) Ember приступает к реализации. Вы можете посмотреть принятые RFC на [доске состояния Ember](https://www.emberjs.com/statusboard).

## Заключение

Просто чтобы прояснить: *React крутой*. Я буду счастлив использовать React на проекте, где будет нужен только React, например заменить шаблоны Rails/Phoenix на React или добавить его к существующему проекту, как дополнение. Но возможно я попробую [glimmerjs](https://glimmerjs.com/), который является эквивалентом React в Ember (view прослойка Ember), но это в основном потому что я уже знаком с Ember и мне нравится движимая сообществом разработка на Ember.

Но использовать React (и его экосистему) для полноценного приложения с множеством роутов/страницы/состояний? Нет, спасибо. Я считаю это хайп и существуют намного лучшие варианты для фронтенд разработчика.