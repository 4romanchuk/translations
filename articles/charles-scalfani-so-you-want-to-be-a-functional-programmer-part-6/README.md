# Итак, вы хотите научиться функциональному программированию (Часть 6)
*Перевод статьи [Charles Scalfani](https://medium.com/@cscalfani): [So You Want to be a Functional Programmer (Part 6)](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-6-db502830403) с [наилучшими пожеланиями от автора](https://twitter.com/cscalfani/status/933052963781722112).*

![Эволюция парадигм программирования](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png)

Первый шаг к пониманию идей функционального программирования – самый важный и иногда самый сложный шаг. Но с правильным подходом никаких трудностей быть не должно.

Предыдущие части: [Часть 1](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-1-6ef98e90d58d), [Часть 2](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-2-ae095d9807b3), [Часть 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158), [Часть 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da), [Часть 5](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-5-d78044d54675).

## Что теперь?

![Вырвитесь из целофанновой реальности](https://cdn-images-1.medium.com/max/800/1*yVZA0aT5t6crvBPAMn46Kg.png)

Теперь, когда вы изучили вcе эти новые классные вещи, вы, возможно, подумаете: "И что теперь? Как мне использовать это в моём обычном коде?".

Здесь возможны разные варианты. Если вы умеете программировать на чистом функциональном языке типа Elm или Haskell, тогда вам будет легко привести в действие механизмы всех этих идей. И такие языки позволят сделать это просто.

Если же вы умеете программировать только на императивном языке типа JavaScript – на том уровне на котором мы все должны это уметь – тогда вы можете продолжить использовать всё, что уже изучили, но теперь должным образом дисциплинируя себя. 

## Функциональный JavaScript

![Работает, как часы](https://cdn-images-1.medium.com/max/800/1*w_gG-CXQX4TV3B5bN24nqg.png)

JavaScript имеет множество фич, позволяющих вам программировать на более функциональный манер. Идеальной чистоты не будет, но вы можете добиться некоторой неизменяемости с помощью самого языка и ещё большей с помощью библиотек.

Не будет идеально, но если вам нужно использовать эти возможности, тогда почему бы не получить некоторые преимущества функционального языка?

### Неизменяемость

Первая вещь, принимаемая во внимание – это неизменяемость. В ES2015 или ES6, как он ещё называется, появилось новое ключевое слово для объявления переменных – `const`. Оно означает, что если однажды переменная была установлена, она не может быть переопределена:

```js
const a = 1;
a = 2; // выбросит TypeError в Chrome, Firefox или Node
       // но не в Safari (на момент 10/2016)
       // (прим. пер.; в Safari всё хорошо с версии 10.1)
```

Здесь `a` определена как константа и по этой причине не может быть изменена после установки. Вот почему выражение `a = 2` выбрасывает ошибку.

Проблема `const` в том, что в JavaScript она не заходит в своей идее так далеко, как должна. Следующий пример проиллюстрирует её предел:

```
const a = {
    x: 1,
    y: 2
};
a.x = 2; // НЕТ ИСКЛЮЧЕНИЯ!
a = {}; // а вот это выбросит TypeError
```

Заметьте, что `a.x = 2` НЕ выбрасывает исключения. Единственное значение, остающееся неизменяемым с `const` – это сама переменная `a`. Всё, что `a` в себе определяет, может быть изменено. 

Это ужасное разочарование, потому что отсутствие такого недостатка сделало бы JavaScript гораздо лучше.

Как же мы можем достичь полной неизменяемости в JavaScript?

К сожалению, это возможно только с помощью библиотеки [Immutable.js](https://facebook.github.io/immutable-js/). Она должна дать нам должный уровень неизменяемости, но, увы, её использование также сделает наш код больше похожим на Java, чем на JavaScript.

### Каррирование и композиция

Раннее, в ондой из предыдущих частей, мы научились писать каррированные функции. Вот более сложный пример:

```js
const f = a => b => c => d => a + b + c + d;
```

Обратите внимание, что нам пришлось написать каррированный фрагмент функции вручную.

И, чтобы вызвать `f`, мы должны написать:

```js
console.log(f(1)(2)(3)(4)); // выведет 10
```

Но здесь получается достаточно круглых скобок, чтобы заставить Lisp-программиста плакать.

Существует множество библиотек, облегчающих задачу каррирования. Одна из моих любимых – [Ramda](http://ramdajs.com/).

Использование Ramda теперь позволяет нам написать:

```js
const f = R.curry((a, b, c, d) => a + b + c + d);
console.log(f(1, 2, 3, 4)); // выведет 10
console.log(f(1, 2)(3, 4)); // также выведет 10
console.log(f(1)(2)(3, 4)); // также выведет 10
```

Определение функции стало выглядеть не намного лучше, зато теперь нам удалось избавиться от нужды во всех этих круглых скобках. Заметьте, что мы можем применять столько же или всего несколько параметров, сколько мы сами пожелаем, когда вызываем `f`.

Используя Ramda, мы можем переписать функцию `mult5AfterAdd10` из [Части 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158) и [Части 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da):

```js
const add = R.curry((x, y) => x + y);
const mult5 = value => value * 5;
const mult5AfterAdd10 = R.compose(mult5, add(10));
```

Пример показывает, что Ramda имеет множество вспомогательных функций для выполнения подобных задач, к примеру `R.add` и `R.multiply`, что означает для нас меньшее количество кода:

```js
const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));
```

### `map`, `filter`, `reduce`

Ramda также имеет свои собственные версии `map`, `filter` и `reduce`. Несмотря на то, что эти функции находятся в `Array.prototype` в Vanilla JS, их версии в Ramda каррированные:

```js
const isOdd = R.flip(R.modulo)(2);
const onlyOdd = R.filter(isOdd);
const isEven = R.complement(isOdd);
const onlyEven = R.filter(isEven);

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(onlyEven(numbers)); // выводит [2, 4, 6, 8]
console.log(onlyOdd(numbers)); // выводит [1, 3, 5, 7]
```

`R.modulo` принимает два параметра. Первый – это ***делимое*** (то, что мы делим) и второй – это ***делитель*** (то, на что мы делим).

Функция `isOdd` возвращает остаток от деления на два. При остатке от нуля, чётного числа, возвращается ***ложь***, при остатке от единицы, нечётного числа – ***истина***. Мы перебросили (*прим. пер.; `flip`*) первый и второй параметр `modulo`, поэтому смогли установить `2`, как делитель.

Функция `isEven` – просто обратная (*прим. пер.; `complement`*) версия `isOdd`.

Функция `onlyOdd` – ***фильтрующая*** функция с предикатом (функцией, возвращающей булево значение) `isOdd`. Она ожидает последнее значение в переданном списке чисел, прежде чем выполнится.

Функция `onlyEven` – ***фильтр***, использующий `isEven`, как предикат.

Когда мы передаём `number` в `onlyEven` и в `onlyOdd`, `isEven` и `isOdd` получают свои последние параметры и могут наконец-то выполнится, возвратив ожидаемые числа. 

## Недостатки JavaScript

![Или всё-таки нет...](https://cdn-images-1.medium.com/max/800/1*GjSzT5C7dKD0GPgSZVFGIw.png)

Со всеми библиотеками и расширяющими возможности средствами языка, которые получил JavaScript, он остаётся страдать из-за того факта, что является императивным языком программирования, пытающимся быть всем для всех людей.

Большинство фронтенд разработчиков застряли на одном месте, используя JavaScript для браузера, потому что он долгое время оставался единственным вариантом. Но сейчас многие разработчики уходят от написания JavaScript-кода напрямую.

Вместо этого они пишут на другом языке и компилируют или, выражаясь точнее, транспилируют его в JavaScript.

Одним из первым таких языков был CoffeeScript. И сейчас на вооружение Angular 2 (*прим. пер.; уже Angular 5 – как быстро летит время!*) был принят TypeScript. Также транспилятором для JavaScript может считаться Babel. 

Всё больше и больше людей прибегают к такому подходу в продакшне.

Но все эти языки начинали с JavaScript и только сделали его немного лучше. Почему бы не пойти до конца и не транспилировать JavaScript из чистого функционального языка?

## Elm

![Elm](https://cdn-images-1.medium.com/max/800/1*oVJSlb6bJfNCXYacQmcvew.png)

В серии статей мы обращались к Elm, чтобы лучше понять функциональное программирование.

***Но что такое Elm? И как мне использовать его?***

Elm – это чистый функциональный язык, компилируемый в JavaScript, поэтому вы можете использовать его для создания веб-приложений, используя [The Elm Architecture](https://guide.elm-lang.org/architecture/), также называемую TEA (эта архитектура вдохновила разработчиков Redux).

У приложений, написанных на Elm, НЕ возникает никаких ошибок выполнения.

Elm используется в продакшене такими компаниями, как [NoRedInk](https://www.noredink.com/), где Эван Чаплики, создатель Elm, сейчас работает (раньше он работал в [Prezi](https://prezi.com/)).

Послушайте этот монолог, [6 Months of Elm in Production](https://www.youtube.com/watch?v=R2FtMbb-nLs) от Ричарда Фельдмана, Elm-евангелиста из NoRedInk для более подробной информации.

***Должен ли я заменить весь свой JavaScript на Elm?***

Нет. Вы можете постепенно заменять части кода. Загляните в эту статью из блога: [How to use Elm at Work](http://elm-lang.org/blog/how-to-use-elm-at-work), – чтобы узнать побольше. 

***Зачем учить Elm?***

1. Программирование на чистом функциональном языке несёт в себе одновременно ограничения и освобождение. Ограничения заключаются в том, что вы можете сделать (зачастую, путём защиты вас от вас самих), но в то же время вы освобождаетесь от ошибок и плохих архитектурных решений, так как Elm-приложения следуют The Elm Architecture, функционально-реактивной модели.

2. Функциональное программирование усовершенствует ваши навыки программиста. Все вышеупомянутые идеи – лишь верхушка айсберга. Вам действительно стоит увидеть их практическую реализацию, чтобы оценить насколько ваши программы уменьшатся в размере и вырастут в показателях стабильности.

3. JavaScript был изначально написан за десять дней и затем пропатчен в течении двух следующих десятков дней, чтобы превратиться в хоть немного функциональный, немного объектно-ориентированный и полноценный императивный язык программирования.
Elm был разработан с учётом накопленного за тридцать лет опыта развития Haskell-сообщества, опирающегося на десятилетия работы в области математики и информатики.
The Elm Architecture (TEA) планировалась и улучшалась на протяжении многих лет и стала результатом личного достижения Эвана в функциональном реактивном программировании. Посмотрите [Controlling Time and Space](https://www.youtube.com/watch?v=Agu6jipKfYw), чтобы оценить уровень мышления, сформулировавшего эту архитектуру.

4. Elm был задуман для фронтенд разработчиков. Он стремится сделать их жизнь проще. Посмотрите [Let’s Be Mainstream](https://www.youtube.com/watch?v=oYk8CKH7OhE), чтобы лучше понимать эту цель.

## Будущее

![Функциональный Гагарин](https://cdn-images-1.medium.com/max/800/1*0FpreasFPaa5rYns6Mpe6w.png)

Невозможно предугадать, что принесёт с собой завтрашний день, но мы можем произвести некоторые граммотные предположения. Вот некоторые из моих:

> *Произойдёт окончательный переход к языкам, компилируемым в JavaScript.*

> *Идеи функционального программирования, витающие вокруг да около на протяжении сорока лет, заново откроют себя, чтобы решить наши насущные проблемы сложности программного обеспечения.*

> *Состояние аппаратного обеспечения, иными словами гигабиты дешёвой памяти и быстрые процессоры, сделает функциональные методы жизнеспособными.*

> *Центральные процессоры не станут работать быстрее, но количество ядер будет продолжать расти.*

> *Переменное состояние будет осмысленно, как одна из основных проблем сложных систем.*

Я написал эту серию статей, потому что верю, что за функциональным программированием будущее и потому что последнюю пару лет прикладывал все усилия, чтобы освоить его (и я всё ещё учусь).

Моей целью являлось помочь другим освоить все эти концепты легче и быстрее, чем мне самому это удалось, и помочь другим поднять их уровень, как программистов, чтобы они стали более востребованными специалистами.

Даже если мой тезис о том, что Elm станет весомым языком в будущем, неверен, я могу сказать с достаточной уверенностью, что функциональное программирование и Elm находятся на одной траектории с движением будущего.

Я надеюсь, что после прочтения этих статей, вы чувствуете себя более увереными в своих способностях и понимаете эти идеи.

Желаю вам удачи в ваших будущих начинаниях.

---

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/%D0%B4%D0%B5%D0%B2%D1%88%D0%B0%D1%85%D1%82%D0%B0/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

[Статья на GitHub](https://github.com/communar/translations/tree/master/articles/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-6)