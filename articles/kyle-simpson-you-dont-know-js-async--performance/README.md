# You Don't Know JS: Async & Performance
# Chapter 1: Asynchrony: Now & Later

Одной из наиболее важных, но часто непонятной части программирования на JavaScript, является способ управления программой, которая выполняется в течение определенного периода времени.

Эта книга не только о том, что происходит в время цикла `for`, выполнение которого *конечно же* требует некоторого времени (от микросекунд до миллисекунд). Эта книга о том, что происходит, когда часть вашей программы выполняется *сейчас*, а другая часть должна выполниться *позже* — то есть о том промежутке между *сейчас* и *позже*, когда ваша программа не выполняется.

Прктически все программы, написанные на JS, так или иначе управляет этим промежутком. Например, при ожидании ввода пользователя, при запросе данных из базы или файловой системы, при отправлении данных по сети и ожидании ответа или выполнении задачи с заданным промежутком времени (например, анимаций). Во всех этих случаях, прогрмма должна управлять состоянием через промежуток времени. Как гласит известная Лондонская пословица ( о яме между дверью вагона и перроне) — "Думай о промежутке".

По факту, взаимосвязь между *сейчас* и *позже* в вашей программе лежит в основе асинхронного программирования.

Асинхронное программирование существует с самого появления JS. Однако, большинство JS-разработчиков не слишком внимательно изучали пути появления асинхронности в своих программах или не слишком внимательно изучали, как применять асинхронность. *Хорошим подходом* всегда была коллбэк-функция. Многие разработчики до сих пор настаивают, что использования коллбэком по-прежнему достаточно для работы.

Но по мере того, как JS продолжает расти по объему и сложности, для удовлетворения постоянно растущих требований к языку программирования, который работает и в браузере и на сервере, приходится искать все новые и новые подходы.

Пока что мы говорим весьма абстактно, но я вас уверяю далее мы рассмотрим множество новых методов для асинхронного программирования на Javascipt.

Но прежде чем двинуться дальше, мы должны заглянуть глубже в суть асинхронности и в то, как она работает в JS.

## Программа по частям

Вы можете написать свою JS-программу в одном *.js* файле, но наверняка ваш код будет разбит на несколько частей. И только онда из частей бкдет выполняться *сейчас*, а оставшаяся часть выполнится *потом*. Функция является наиболее используемым приемом деления программы на части.

Основная проблема большинства разработчиков, которые впервые видят JS — это непонимание того, что *потом* не произойдет немедленно после *сейчас*. Другими словами, задачи, которые не могут быть завершены *сейчас*, по определению, будут завершаться асинхронно. И у нас не будет блокирующего поведения программы, которое мы предполагаем.

Рассмотрим пример:

```javascript
// ajax(..) некоторая Ajax-функция, предоставляемая библиотекой
var data = ajax( "http://some.url.1" );

console.log( data );
// Упс! в `data` не будут записаны результаты Ajax-операции
```

Вероятно, вы знаете, что стандартный Ajax-запрос не завершается синхронно. Это значит, что функция `ajax(...)`, еще не иммеет никакого значение, которое можно было бы вернуть и присвоить переменной `data`. Если `ajax(...)` можно заблокировать, до тех пор пока ответ не вернется, то присваивание `data = ...` будет работать нормально.

Но Ajax-запросы так не применяются. Мы выполняем асинхронный Ajax-запрос сейчас, и мы не получим данные *потом*.

Простейший (но не едиественный и не обязательно самый лучший) способ "подождать" от *сейчас* до *потом*, является использование колбэков:

```javascript
ajax( "http://some.url.1", function myCallbackFunction(data){

	console.log( data ); // Даа, я получил данные!

} );
```

**Внимание**: вы могли слышать о возможности выполнять синхронные Ajax-запросы. С технической точки зрения такое действтельно возможно. Однако, вы не должны делать этого ни при каких обстоятельствах, потому что это блокирует интерфейс браузера (кнопки, меню, скроллинг и.т.д) и блокируется пользовательское взаимодействие. Это ужасная идея и ее следует избегать.

Стремление избежать т.н *callback hell*, не является оправданием для испольщования синхронного Ajax.

Рассмотрим такой пример:

```javascript
function now() {
	return 21;
}

function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}

var answer = now();

setTimeout( later, 1000 ); // Meaning of life: 42
```

Тут есть две части: одна часть кода выполнится *сейчас*, другая часть *потом*. Очевидно быть достаточно очевидно, как работают эти две части, но давайте будем супер очевидными:

Сейчас:

```javascript
function now() {
	return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```
Потом:

``` javascript
answer = answer * 2;
console.log( "Meaning of life:", answer );
```

Часть *сейчас* запустится сразу, по ходу выполнения прогрмаммы. Но `setTimeout()` добавляется новое событие (задержку), которое выполнится *потом*, поэтому содержимое функции `later()` будет выполнено позднее (через 1000 миллисекунд).

Каждый раз, когда вы переносите часть кода в функцию, и указываете, что она должна сработатать при определенном событии (таймер, клик, Ajax-запрос), вы создаете часть *потом*, и следовательно, добавляете асинхронности к вашей программе.

## Асинхронный console()

Нет спецификации или требований, описывающих работу `console.*` методов — они не являются официальной частью JavaScript. Вместо этого оени добавлены в JS с помощью среды хоистинга (see the Types & Grammar title of this book series).

Таким образом различные браузеры и среды работают с `console.*`, так, как им заблагорассудится, что приводит к запутанным ситауциям.

В частности, есть некоторые браузеры и некоторые условия при которых `console.log()` выведет не то, что ему передали. Основная причина по которой это может произойти, заключается в том, что I/O медленный и блокирует выполнение некотрых программ (не только в JS). Таким образом лучше (с точки зрения UI), чтобы консольные методы работали асинхронно в фоновом режиме.

Вот не очень распространенный, но возможный сценарий, где такое поведение можно наблюдать:

```javascript
var a = {
	index: 1
};

// позже
console.log( a ); // ??

// еще позже
a.index++;
```

Обычно мы предполагаем, что `console.log()` выведет, что то типа `{index: 1}`, так что в следующей строке, где происходит `a.index++`, меняется что то другое, отличное от вывода `a`.


В большинстве случаев код выше выполнится в девтулзах, как и предполагается. Но что если выполнить этот же код в ситуации, когда браузеру нужно отложить консольный I/O. В таком случае возможно, что когда объект попадет в консоль, `a.index++` уже выполнится, и мы увидим результат `{index: 2}`.

**Замечание:** Если вы столкнулись с этим редким сценарием, то хорошим решением будет использование брейкпоинтов в дебаггере, вместо логов в `console`. Еще хорошим решением будет создание «снэпшота» объекта, путем сериализации его в строку с помощью `JSON.stringify(..)`.

## Цикл событий

Сделаю замечание (возможно, шокирующее): несмотря на то, что мы выполняем асинхронный JS-код (например таймаут из примеров выше), до недавнего времени(ES6), в JS не было прямого представления об асинхронности внутри себя.

**Что ?!** Похоже на дурацкую шутку. Но по факту это правда. Раньше JS-движок не делал ничего, кроме выполнения части кода по запросу.

"По запросу". От кого? Это важно!


Движок JS не работает изолированно. Он работает в *среде хостинга*. Для большинства разработчиков такой средой является веб-браузер. В течение последних лет JS вышел за пределы браузеров и стал использоваться в других средах, например на серверах через Node.js. На сегодняшний день JavaScript внедряется во всевозможны устройства, от роботов до лампочек.

Одной общей концепцией, связывющей эти среды, является наличие в них механизма, обрабатывающего несколько частей кода с течением времени, при каждом вызове движка. Этот мехенизм назвали "циклом событий".

Другими словами, JS-движок не имел врожденного чувства *времени*, зато имел специфическую среду выполения по требованию любого произвольного фрагмента кода. В этой среде существовало некое "расписание" *событий* (выполнения JS-кода).

Например, когда ваша программа делает Ajax-запрос, чтобы получить какие то данные от сервера, вы устанавливаете получение ответа в виде колбэка, а JS-движок сообщает среде выполнения "Эй, я собираюсь проиостановить выполенение кода, но всякий раз, когды ты завершаешь этот сетевой запрос, то *вызывай* эту функцию *обратно*."

Затем браузер настраивается на обработку ответа от сети, и когда есть, что вернуть, "планирует" выполнение колбэка, вставив его в *цикл событий*.

Что же такое *цикл событий*?
Давайте, представим его в виде некого псевдокода:

``` javascript
// `eventLoop` — это массив, который работает, как очередь
var eventLoop = [ ];
var event;

// keep going "forever"
while (true) {
	// шаг цикла
	if (eventLoop.length > 0) {
		// получение следующего события в очереди
		event = eventLoop.shift();

		// выполнение следующего события
		try {
			event();
		}
		catch (err) {
			reportError(err);
		}
	}
}

```

Это, конечно, весьма упрощенная иллюстрация концепции цикла событий. Но ее достаточно для более глубокого понимания.

Как вы видите, существует непрерывный цикл, представленный циклом `while`. Каждая итерация этого цикла называется "тиком". Если в тике есть событие, "ожидающее" очереди, то оно берется и выполняется. Эти события — это ваши колбэки.

Важно отметить, что `setTimeout()` не помещает ваш колбэк в очередь цикла событий. Он устанавливает таймер; когда таймер истекает, среда помещает колбэк обратно в цикл, так, что будущий тик забирает его и выполняет.

Но что, если в цикле событий уже есть 20 элементов? Ваш колбэк ждет. Он находится в очереди за другими событиями, обычно нет способа обойти эту очередь. Это объясняет, почему `setTimeout()` таймеры не срабатывают вовремя. Можете быть уверены, что колбек не сработает в запланированное время. Срабатывание зависит от состояния очереди.

Таким образом, ваша прогрмма, как правило, разбивается на небольшиче части, который выполняются одна за другой в очереди цикла событий. И технически, другие события, не связанные непосредственно с вашей программой, также могут чередоваться в очереди.

**Замечание:** мы упомянули "до недавнего времени" относительно ES6, который изменил характер управления очередью событий. В основном это формальная информация, но теперь в ES6 появилась спецификация, описывающая работу цикла событий. Это означет, что механизм цикла событий теперь входит в компетенцию JS-движка, а не только в компетенцию *среды выполения*. Одной из основных причин таких изменений, является появления в ES6 Промисов (о которых будет рассказано в 3-й главе), потому что они требуют возможности иметь прямой контроль над процессами цикла событий.

## Parallel Threading

Очень часто "асинхронность" и "параллельность" объединяют. Но, конечно, это разные вещи. Асинхронный процесс связяан с промежутком между *сейчас* и *потом*, а параллельность связана с **одновременным** выполнением процессов.

Наиболее распространенными инструментами для параллельных вычислений являются процессы и потоки. Процессы и потоки выполняются независимо и могут выполняться одновременно: на отдельных процессорах или даже на отдельных компьютерах, но несколько потоков могут совместно использовать память одного процесса.

Цикл событий, напротив, разбивает работу на задачи и выполняет их последовательно, запрещая параллельный доступ и изменения в общей памяти. Параллелизм и «сериализм» могут сосуществовать в форме взаимодействующих циклов событий в отдельных потоках.

Перемешивание параллельных потоков выполнения и чередование асинхронных событий происходит на очень разных уровнях.

Например:

```javascript

function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}

```
Выполнение содержимого `later()` может рассматриваться, как операция добавления в очередь цикла событий с помощью одного потока. Но на самом деле тут выполняется целая дюжина низкоуровневых операций.

Например, `answer = answer * 2` требует сначала загрузить текущее значение `answer`, затем положить 2 в другое место, затем выполнить умножение, затем взять результат и сохранить его обратно в `answer`.

В однопоточной среде не имеет значения, что элементы очереди это низкоуровневые операции, потому что ничто не пожет прервать поток. Однако, если у вас параллельная система, где два потока работают в одной программе, то может возникнуть неочевидная проблема.

Например:

```javascript
var a = 20;

function foo() {
	a = a + 1;
}

function bar() {
	a = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );

```

В однотопоточном варианте, если `foo()` выполняется до `bar()` , то в результате `a` будет равно `42`, если `bar()` выполнится раньше, то результат будет `41`.

Если события JS совместно используют одни и те же данные, выполненные параллельно, проблемы будут гораздо более тонкими. Рассмотрим два варианта псевдокода в виде потоков, которые выполняют код в foo () и bar () **одновременно**:

Поток 1 (X и Y - временные ячейки памяти)

```javascript
foo():
  a. загружает значение `a` в `X`
  b. сохраняет `1` в `Y`
  c. складывает `X` и `Y`, сохраняет результат в `X`
  d. сохраняет значение `X` в `a`
```

Поток 2 (X и Y - временные ячейки памяти)

```javascript
bar():
  a. загружает значение`a` в `X`
  b. сохраняет `2` в `Y`
  c. умножает `X` на `Y`, сохраняет результат в `X`
  d. сохраняет`X` в `a`
```
Подчеркнем, что потоки работают **параллельно**. Выроятно, вы уже заметили проблему? Потоки используют общие ячейки памяти Х и Y.

Что в результате мы получим в `a`, если потоки выполнятся в таком порядке?

```javascript
1a  (загружает значение `a` в `X`   ==> `20`)
2a  (загружает значение `a` в `X`   ==> `20`)
1b  (сохраняет `1` в `Y`   ==> `1`)
2b  (сохраняет `2` в `Y`   ==> `2`)
1c  (складывает `X` и `Y`, сохраняет результат в `X`   ==> `22`)
1d  (сохраняет значение `X` в `a`   ==> `22`)
2c  (умножает `X` на `Y`, сохраняет результат в `X`   ==> `44`)
2d  (сохраняет значение `X` в `a`   ==> `44`)
```
Результат будет равен 44. А если в таком порядке?

```javascript
1a  (загружает значение `a` в `X`   ==> `20`)
2a  (загружает значение `a` в `X`   ==> `20`)
2b  (сохраняет `2` в `Y`   ==> `2`)
1b  (сохраняет `1` в `Y`   ==> `1`)
2c  (умножает `X` на `Y`, сохраняет результат в `X`   ==> `20`)
1c  (складывает `X` и `Y`, сохраняет результат в `X`   ==> `21`)
1d  (сохраняет значение `X` в `a`   ==> `21`)
2d  (сохраняет значение `X` в `a`   ==> `21`)
```
Результат будет равен 21.

Таким образом, можно сказать, что параллельное программирвание очень сложное. Потому что у нас нет возможности избегать чередования порядка выполнения потоков, что может доставить ощутимые неприятности.

JavaScript никогда не делит данные по потокам, а это означает, что уровень неопределенности выполнения кода не вызывает беспокойства. Но это не значит, что JS всегда выполняет код определенно точно. Помните пример, когда относительное упорядочение выполнение foo () и bar () давало два разных результата (41 или 42)?

**Замечание:** Возможно, это еще не очевидно, но не все неочевидное плохо. Мы увидим больше примеров в этой и следующих нескольких главах.

## От выполнения до завершения

Из-за однопоточности JavaScript код внутри foo () (и bar ()) является атомарным, что означает, что после запуска foo () весь его код завершится до того, как какой-либо код в bar () хапустится или наоборот. Это называется поведением «от выполнения до завершения».

На самом деле семантика "от выполнения до завершения" более очевидна, когда foo () и bar () имеют больше кода, например:

```javascript
var a = 1;
var b = 2;

function foo() {
	a++;
	b = b * a;
	a = b + 3;
}

function bar() {
	b--;
	a = 8 + b;
	b = a * 2;
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```
Поскольку `foo()` не может быть прерван с помощью `bar()`, а `bar()` не может быть прерван `foo()`, эта программа имеет только два возможных результата, в зависимости от того, что начнет выполнятся в первую очередь. Но если есть многопоточночть, то количество возможных результатов будет значительно увеличено!

Часть 1 синхронная (выполнится *сейчас*), но части 2 и 3 являются асинхронными (выполнятся *потом*), что означает, что их выполнение будет отделено промежутком времени.

Часть 1:

```javascript
var a = 1;
var b = 2;
```

Часть 2 (`foo()`):

```javascript
a++;
b = b * a;
a = b + 3;
```

Часть 3 (`bar()`):

```javascript
b--;
a = 8 + b;
b = a * 2;
```

Выполнение частей 2 и 3 может чередоваться , поэтому для этой программы возможны два варианта результата:


Вариант 1:
```javascript
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;

a; // 11
b; // 22
```

Вариант 2:
```javascript
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;

// foo()
a++;
b = b * a;
a = b + 3;

a; // 183
b; // 180
```

Два результата одного и того же кода означают, ту самую **неопределенность**! Но она связана с порядком выполения функции (события), а не с порядком выполнения операций **внутри**, как в случае с потоками. Другими словами, такой способ выполнения кода более **определенный**, чем потоки.

Что касается поведения JavaScript, то эта неопределенность функции называется термином «состояние гонки». `foo()` и `bar()` участвуют в гонке друг против друга, чтобы выполнится раньше оппонента. В частности, это «состояние гонки» является причиной того, почему что вы не можете точно предсказать, конечный результат a и b.

**Замечание:** Что если бы у нас была функция, имеющая поведение, отличное от "выполненияе до завершения"? Мы бы имели гораздо больше возможных результатов этой функции. Оказывается, в ES6 плявилась вещь (см. Главу 4 «Генераторы»), но не беспокойтесь, мы еще вернемся к этому!

## Параллелизм

Представим себе сайт, на котором отображается список обновлений. Например, лента новостей социальных сетей, которая постепенно загружается, когда пользователь прокручивает список вниз. Для работы такой функции требуется, по крайней мере, два отдельных «процесса», выполняемых одновременно (то есть в течение одного и того же времени, но не обязательно в одно и то же мгновение).

**Примечание:** Мы используем слово «процессы» в кавычках, потому что это не настоящие операционные процессы на уровне системы, как предполагет компьютерная наука. Это виртуальные процессы или задачи, которые представляют собой логически связанные, последовательные серии операций. Для нас предпочтительней испольщовать «процесс» нежели «задача», потому что такая терминология лучше отражает концепции, которые мы изучаем.


Первый «процесс» будет запускаться при событии `onscroll` (делая запросы Ajax-зарос для нового контента), когда пользователь прокручивает страницу вниз. Второй «процесс» Ajax'ом возвращает ответ (чтобы отобразить содержимое на странице).

Очевидно, что если пользователь скроллит достаточно быстро, вы можете увидеть два или более события `onscroll`, запущенных за время, необходимое для получения первого ответа и обработки. Таким образом, вы будете иметь события onscroll и ajax-ответы, часто вызывающиеся и чередующиеся друг с другом.

Параллелизм — это когда два или более «процесса» выполняются одновременно за тот же период, независимо от того, происходят ли их отдельные составляющие операции параллельно (в тот же момент на отдельных процессорах или ядрах) или нет. Вы можете думать о параллелизме, как о параллельности "процесса" (или уровне задачи), в отличие от параллелизма на уровне операций (выполнение потоков отдельных процессоров).

Note: Concurrency also introduces an optional notion of these "processes" interacting with each other. We'll come back to that later.


 Давайте визуализируем каждый независимый «процесс», как последовательность событий / операций в течение заданного времени (несколько секунд для прокрутки пользователем):

 "Процесс" 1 (`onscroll` события):

 ```javascript
 onscroll, запрос 1
 onscroll, запрос 2
 onscroll, запрос 3
 onscroll, запрос 4
 onscroll, запрос 5
 onscroll, запрос 6
 onscroll, запрос 7
 ```

 "Процесс" 2 (Ajax-ответ):

 ```javascript
ответ 1
ответ 2
ответ 3
ответ 4
ответ 5
ответ 6
ответ 7
 ```
Вполне возможно, что событие onscroll и ajax-ответ могут быть готовы к выполнения в *один и тот же момент*. Давайте визуализируем эти события на временной шкале:

```javascript
onscroll, запрос 1
onscroll, запрос 2          ответ 1
onscroll, запрос 3          ответ 2
response 3
onscroll, запрос 4
onscroll, запрос 5
onscroll, запрос 6          ответ 4
onscroll, запрос 7
ответ 6
ответ 5
ответ 7
```

Но, памятуя о работе цикла событий, мы знаем, что JS может обрабатывать только одно событие за раз (тик), так что либо `onscroll, запрос 2` произойдет первым, либо `ответ 1` первым, но они **не могут** произойти буквально в **один и тот же момент**. Так же, как дети в школьной столовой, независимо от того, какую толпу они образуют за дверью, им придется встать в одну линию за обедом!

Давайте визуализируем чередование всех этих событий в очереди цикла событий:

```javascript
onscroll, запрос 1   <--- Процесс 1 начался
onscroll, запрос 2
ответ 1            <--- Процесс 2 начался
onscroll, запрос 3
ответ 2
ответ 3
onscroll, запрос 4
onscroll, запрос 5
onscroll, запрос 6
ответ 4
onscroll, запрос 7   <--- Процесс 1 завершился
ответ 6
ответ 5
ответ 7            <--- Процесс 2 завершился
```

«Процесс 1» и «Процесс 2» выполняются одновременно (параллелизм "процессв"), но их отдельные события выполняются последовательно в очереди цикла событий.

Кстати, обратите внимание, ответ 6 и ответ 5 выполнились в ожидаемом порядке?
Однопоточный цикл событий является одной из ипостасей параллелизма (есть, безусловно, другие, о которых мы поговорим позже).
