# You Don't Know JS: Async & Performance
# Chapter 1: Asynchrony: Now & Later

Одной из наиболее важных, но часто непонятной части программирования на JavaScript, является способ управления программой, которая выполняется в течение определенного периода времени.

Эта книга не только о том, что происходит в время цикла `for`, выполнение которого *конечно же* требует некоторого времени (от микросекунд до миллисекунд). Эта книга о том, что происходит, когда часть вашей программы выполняется *сейчас*, а другая часть должна выполниться *позже* — то есть о том промежутке между *сейчас* и *позже*, когда ваша программа не выполняется.

Прктически все программы, написанные на JS, так или иначе управляет этим промежутком. Например, при ожидании ввода пользователя, при запросе данных из базы или файловой системы, при отправлении данных по сети и ожидании ответа или выполнении задачи с заданным промежутком времени (например, анимаций). Во всех этих случаях, прогрмма должна управлять состоянием через промежуток времени. Как гласит известная Лондонская пословица ( о яме между дверью вагона и перроне) — "Думай о промежутке".

По факту, взаимосвязь между *сейчас* и *позже* в вашей программе лежит в основе асинхронного программирования.

Асинхронное программирование существует с самого появления JS. Однако, большинство JS-разработчиков не слишком внимательно изучали пути появления асинхронности в своих программах или не слишком внимательно изучали, как применять асинхронность. *Хорошим подходом* всегда была коллбэк-функция. Многие разработчики до сих пор настаивают, что использования коллбэком по-прежнему достаточно для работы.

Но по мере того, как JS продолжает расти по объему и сложности, для удовлетворения постоянно растущих требований к языку программирования, который работает и в браузере и на сервере, приходится искать все новые и новые подходы.

Пока что мы говорим весьма абстактно, но я вас уверяю далее мы рассмотрим множество новых методов для асинхронного программирования на Javascipt.

Но прежде чем двинуться дальше, мы должны заглянуть глубже в суть асинхронности и в то, как она работает в JS.

## Программа по частям

Вы можете написать свою JS-программу в одном *.js* файле, но наверняка ваш код будет разбит на несколько частей. И только онда из частей бкдет выполняться *сейчас*, а оставшаяся часть выполнится *потом*. Функция является наиболее используемым приемом деления программы на части.

Основная проблема большинства разработчиков, которые впервые видят JS — это непонимание того, что *потом* не произойдет немедленно после *сейчас*. Другими словами, задачи, которые не могут быть завершены *сейчас*, по определению, будут завершаться асинхронно. И у нас не будет блокирующего поведения программы, которое мы предполагаем.

Рассмотрим пример:

```javascript
// ajax(..) некоторая Ajax-функция, предоставляемая библиотекой
var data = ajax( "http://some.url.1" );

console.log( data );
// Упс! в `data` не будут записаны результаты Ajax-операции
```

Вероятно, вы знаете, что стандартный Ajax-запрос не завершается синхронно. Это значит, что функция `ajax(...)`, еще не иммеет никакого значение, которое можно было бы вернуть и присвоить переменной `data`. Если `ajax(...)` можно заблокировать, до тех пор пока ответ не вернется, то присваивание `data = ...` будет работать нормально.

Но Ajax-запросы так не применяются. Мы выполняем асинхронный Ajax-запрос сейчас, и мы не получим данные *потом*.

Простейший (но не едиественный и не обязательно самый лучший) способ "подождать" от *сейчас* до *потом*, является использование колбэков:

```javascript
ajax( "http://some.url.1", function myCallbackFunction(data){

	console.log( data ); // Даа, я получил данные!

} );
```

**Внимание**: вы могли слышать о возможности выполнять синхронные Ajax-запросы. С технической точки зрения такое действтельно возможно. Однако, вы не должны делать этого ни при каких обстоятельствах, потому что это блокирует интерфейс браузера (кнопки, меню, скроллинг и.т.д) и блокируется пользовательское взаимодействие. Это ужасная идея и ее следует избегать.

Стремление избежать т.н *callback hell*, не является оправданием для испольщования синхронного Ajax.

Рассмотрим такой пример:

```javascript
function now() {
	return 21;
}

function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}

var answer = now();

setTimeout( later, 1000 ); // Meaning of life: 42
```

Тут есть две части: одна часть кода выполнится *сейчас*, другая часть *потом*. Очевидно быть достаточно очевидно, как работают эти две части, но давайте будем супер очевидными:

Сейчас:

```javascript
function now() {
	return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```
Потом:

``` javascript
answer = answer * 2;
console.log( "Meaning of life:", answer );
```

Часть *сейчас* запустится сразу, по ходу выполнения прогрмаммы. Но `setTimeout()` добавляется новое событие (задержку), которое выполнится *потом*, поэтому содержимое функции `later()` будет выполнено позднее (через 1000 миллисекунд).

Каждый раз, когда вы переносите часть кода в функцию, и указываете, что она должна сработатать при определенном событии (таймер, клик, Ajax-запрос), вы создаете часть *потом*, и следовательно, добавляете асинхронности к вашей программе.

## Асинхронный console()

Нет спецификации или требований, описывающих работу `console.*` методов — они не являются официальной частью JavaScript. Вместо этого оени добавлены в JS с помощью среды хоистинга (see the Types & Grammar title of this book series).

Таким образом различные браузеры и среды работают с `console.*`, так, как им заблагорассудится, что приводит к запутанным ситауциям.

В частности, есть некоторые браузеры и некоторые условия при которых `console.log()` выведет не то, что ему передали. Основная причина по которой это может произойти, заключается в том, что I/O медленный и блокирует выполнение некотрых программ (не только в JS). Таким образом лучше (с точки зрения UI), чтобы консольные методы работали асинхронно в фоновом режиме.

Вот не очень распространенный, но возможный сценарий, где такое поведение можно наблюдать:

```javascript
var a = {
	index: 1
};

// позже
console.log( a ); // ??

// еще позже
a.index++;
```

Обычно мы предполагаем, что `console.log()` выведет, что то типа `{index: 1}`, так что в следующей строке, где происходит `a.index++`, меняется что то другое, отличное от вывода `a`.


В большинстве случаев код выше выполнится в девтулзах, как и предполагается. Но что если выполнить этот же код в ситуации, когда браузеру нужно отложить консольный I/O. В таком случае возможно, что когда объект попадет в консоль, `a.index++` уже выполнится, и мы увидим результат `{index: 2}`.

**Замечание:** Если вы столкнулись с этим редким сценарием, то хорошим решением будет использование брейкпоинтов в дебаггере, вместо логов в `console`. Еще хорошим решением будет создание «снэпшота» объекта, путем сериализации его в строку с помощью `JSON.stringify(..)`.

## Цикл событий

Сделаю замечание (возможно, шокирующее): несмотря на то, что мы выполняем асинхронный JS-код (например таймаут из примеров выше), до недавнего времени(ES6), в JS не было прямого представления об асинхронности внутри себя.

**Что ?!** Похоже на дурацкую шутку. Но по факту это правда. Раньше JS-движок не делал ничего, кроме выполнения части кода по запросу.

"По запросу". От кого? Это важно!


Движок JS не работает изолированно. Он работает в *среде хостинга*. Для большинства разработчиков такой средой является веб-браузер. В течение последних лет JS вышел за пределы браузеров и стал использоваться в других средах, например на серверах через Node.js. На сегодняшний день JavaScript внедряется во всевозможны устройства, от роботов до лампочек.

Одной общей концепцией, связывющей эти среды, является наличие в них механизма, обрабатывающего несколько частей кода с течением времени, при каждом вызове движка. Этот мехенизм назвали "циклом событий".

Другими словами, JS-движок не имел врожденного чувства *времени*, зато имел специфическую среду выполения по требованию любого произвольного фрагмента кода. В этой среде существовало некое "расписание" *событий* (выполнения JS-кода).

Например, когда ваша программа делает Ajax-запрос, чтобы получить какие то данные от сервера, вы устанавливаете получение ответа в виде колбэка, а JS-движок сообщает среде выполнения "Эй, я собираюсь проиостановить выполенение кода, но всякий раз, когды ты завершаешь этот сетевой запрос, то *вызывай* эту функцию *обратно*."

Затем браузер настраивается на обработку ответа от сети, и когда есть, что вернуть, "планирует" выполнение колбэка, вставив его в *цикл событий*.

Что же такое *цикл событий*?
Давайте, представим его в виде некого псевдокода:

``` javascript
// `eventLoop` — это массив, который работает, как очередь
var eventLoop = [ ];
var event;

// keep going "forever"
while (true) {
	// шаг цикла
	if (eventLoop.length > 0) {
		// получение следующего события в очереди
		event = eventLoop.shift();

		// выполнение следующего события
		try {
			event();
		}
		catch (err) {
			reportError(err);
		}
	}
}

```

Это, конечно, весьма упрощенная иллюстрация концепции цикла событий. Но ее достаточно для более глубокого понимания.

Как вы видите, существует непрерывный цикл, представленный циклом `while`. Каждая итерация этого цикла называется "тиком". Если в тике есть событие, "ожидающее" очереди, то оно берется и выполняется. Эти события — это ваши колбэки.

Важно отметить, что `setTimeout()` не помещает ваш колбэк в очередь цикла событий. Он устанавливает таймер; когда таймер истекает, среда помещает колбэк обратно в цикл, так, что будущий тик забирает его и выполняет.

Но что, если в цикле событий уже есть 20 элементов? Ваш колбэк ждет. Он находится в очереди за другими событиями, обычно нет способа обойти эту очередь. Это объясняет, почему `setTimeout()` таймеры не срабатывают вовремя. Можете быть уверены, что колбек не сработает в запланированное время. Срабатывание зависит от состояния очереди.

Таким образом, ваша прогрмма, как правило, разбивается на небольшиче части, который выполняются одна за другой в очереди цикла событий. И технически, другие события, не связанные непосредственно с вашей программой, также могут чередоваться в очереди.

**Замечание:** мы упомянули "до недавнего времени" относительно ES6, который изменил характер управления очередью событий. В основном это формальная информация, но теперь в ES6 появилась спецификация, описывающая работу цикла событий. Это означет, что механизм цикла событий теперь входит в компетенцию JS-движка, а не только в компетенцию *среды выполения*. Одной из основных причин таких изменений, является появления в ES6 Промисов (о которых будет рассказано в 3-й главе), потому что они требуют возможности иметь прямой контроль над процессами цикла событий.

## Parallel Threading

Очень часто "асинхронность" и "параллельность" объединяют. Но, конечно, это разные вещи. Асинхронный процесс связяан с промежутком между *сейчас* и *потом*, а параллельность связана с **одновременным** выполнением процессов.

Наиболее распространенными инструментами для параллельных вычислений являются процессы и потоки. Процессы и потоки выполняются независимо и могут выполняться одновременно: на отдельных процессорах или даже на отдельных компьютерах, но несколько потоков могут совместно использовать память одного процесса.

Цикл событий, напротив, разбивает работу на задачи и выполняет их последовательно, запрещая параллельный доступ и изменения в общей памяти. Параллелизм и «сериализм» могут сосуществовать в форме взаимодействующих циклов событий в отдельных потоках.

Перемешивание параллельных потоков выполнения и чередование асинхронных событий происходит на очень разных уровнях.

Например:

```javascript

function later() {
	answer = answer * 2;
	console.log( "Meaning of life:", answer );
}

```
Выполнение содержимого `later()` может рассматриваться, как операция добавления в очередь цикла событий с помощью одного потока. Но на самом деле тут выполняется целая дюжина низкоуровневых операций.

Например, `answer = answer * 2` требует сначала загрузить текущее значение `answer`, затем положить 2 в другое место, затем выполнить умножение, затем взять результат и сохранить его обратно в `answer`.

В однопоточной среде не имеет значения, что элементы очереди это низкоуровневые операции, потому что ничто не пожет прервать поток. Однако, если у вас параллельная система, где два потока работают в одной программе, то может возникнуть неочевидная ситуация.
