# Итак, Вы хотите научиться функциональному программированию (Часть 1)
*Перевод статьи [Charles Scalfani](https://medium.com/@cscalfani): [So You Want to be a Functional Programmer (Part 1)](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536) с [наилучшими пожеланиями от автора](https://twitter.com/cscalfani/status/933052963781722112)*

![Эволюция парадигм программирования](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png)

Первый шаг к пониманию идей функционального программирования – самый важный и иногда самый сложный шаг. Но с правильным подходом никаких трудностей быть не должно.

#### Обучение вождению

![Первое занятие по вождению](https://cdn-images-1.medium.com/max/800/1*3aCyRpNew24v3PLXxu4VxQ.png)

Когда мы только учились водить машину, мы старались изо всех сил. Конечно, это выглядело легко, когда мы смотрели как водят другие люди. Но на деле всё оказывалось сложнее.

Мы упражнялись на машине родителей и не выезжали на автострады, пока в совершенстве не осваивали улицы родного района.

После множества практических занятий и нескольких щекотливых моментов, о которых наши родители хотели бы забыть, мы выучивались вождению и наконец получали свои водительские права.

С правами в руках мы садились за руль при любом удобном случае. С каждой новой поездкой наши навыки становились всё лучше и лучше, уверенность росла. Затем наступал день, когда нам приходилось вести другую машину или наша собственная приказывала долго жить и мы покупали новую.

Вспомните на что это было похоже – первый раз за рулём ***другой машины***? Было ли это похоже на ***самый первый раз*** за рулём машины вообще? Даже не близко. В первый раз всё было таким незнакомым. Конечно, мы были до этого в машине, но только в роли пассажира. На этот раз мы оказывались в сидении водителя. Один на один со всеми рычагами, кнопками и педалями.

Но когда мы вели нашу вторую машину, мы просто задавали себе несколько простых вопросов по типу: куда вставляется ключ, где переключаются фары ближнего и дальнего света, как использовать поворотники и как настроить зеркала заднего вида. 

После всего этого мы вели свою машину как по маслу. Но почему в этот раз всё было так просто по сравнению с первым разом?

Потому что новая машина была достаточно похожа на старую. Она имела все те базовые элементы, что нужны машине, и в большинстве случаев они находились на тех же местах, что и в старой.

Может, несколько вещей были реализованы как-то иначе и, может быть, они имели какие-то дополнительные функциональные возможности, но мы и так не использовали их во всём нашем водительском опыте. Рано или поздно мы изучали все новые примочки. Как минимум, те, что нам реально требовались.

Что ж, процесс изучения языков программирования похож на процесс обучения вождению. Первый раз – самый сложный. Но с багажом опыта за плечами всё последующее обучение становится проще.

Когда Вы начинаете изучать второй язык, Вы спрашиваете себя: "Как мне создать модуль? Как реализовать поиск по массиву? Какие параметры принимает функция нахождения подстроки?"

Вы уверены, что можете "научиться водить" на этом новом языке, потому что он напоминает Вам о предыдущем языке, может, с несколькими новыми элементами, которые, надо надеяться, сделают Вашу жизнь легче.

#### Ваш первый космический корабль

![Вы за штурвалом космического корабля](https://cdn-images-1.medium.com/max/800/1*ZLJIz9OrgCHCTST9KOcHIQ.png)

Ездили ли Вы на одном автомобиле всю свою жизнь или на десятках автомобилях, представьте, что собираетесь сесть за штурвал космического корабля. 

Если Вы собираетесь летать на таком аппарате, то вряд ли будете надеяться, что навыки вождения на дороге как-то особенно Вам помогут. Вы начнёте всё с нуля (*Мы же программисты, чёрт возьми. Мы начинаем считать с нуля*.)

Вы начнёте свои тренировки с расчётом, что вещи в космосе существуют иначе и что полёты на этой штуковине довольно отличны от вождения машины по земле.

Однако физика не изменилась. Путь, по которому вы двигаетесь находится в пределах всё той же Вселенной. 

Такой же подход должен быть к изучению функционального программирования. Вы должны учитывать, что всё будет по-другому. И то многое, что Вы знали о программировании не будет перенесено в новую область.

Программировать – значит мыслить и функциональное программирование научит Вас мыслить совсем по-другому настолько, что Вы вероятно никогда не вернётесь назад на старый путь образа мышления.  

#### Забудьте всё, что Вы знаете

![Один из вариантов как забыть всё](https://cdn-images-1.medium.com/max/800/1*PoIg8NuGaH3XQkQ8Ctz6hw.png)

Люди любят говорить эту фразу и в ней действительно есть доля правды. ***Обучение функциональному программированию – значит учиться всему с нуля***. Не полностью, конечно, но фактически это так. В этой теме существует множество простых концепций, но Вам лучше приготовиться к тому, что придётся ***переучивать всё***.

С правильным подходом у Вас будут правильные ожидания, а с правильными ожиданиями Вы не захотите бросить дело, когда начнутся вещи по-тяжелее.

Есть также многие вещи, которые Вы привыкли делать, как программист, но которые Вы не сможете больше делать, занимаясь функциональным программированием.

Вспомните, как Вы, чтобы выехать с проезжей части, давали задний ход на машине. Но на космическом корабле нет механизма реверса. Теперь Вы должны подумать: "ЧТО? НЕТ ЗАДНЕГО ХОДА? КАК Я ДОЛЖЕН ВОДИТЬ БЕЗ ЗАДНЕГО ХОДА?"

Что ж, оказывается Вам не нужен реверс на космическом корабле, способном маневрировать в трёхмерном пространстве космоса. Как только Вы поймёте это, Вы больше не будете вспоминать о возможности заднего хода. И однажды, Вы даже задумаетесь о том, насколько, на самом деле, ограничены обыкновенные машины.

> *Изучение функционального программирования требует времени. Так что запаситесь терпением*.

Так что давайте покинем холодный мир императивного и медленно окунёмся в горячие источники функционального программирования.

То, что следует в этой комплексной статье – концепции функционального программирования, которые помогут Вам перед полным погружением в первый функциональный язык. Или, если Вы уже сделали решительный шаг в этой сфере, эта параграфы помогут заточить понимание идей. 

Пожалуйста, не спешите. С этого момента не торопитесь и находите время, чтобы понять примеры кода. Лучше будет даже сделать небольшую паузу в прочтении после этой части статьи и дать озвученным идеям "устаканиться". Затем возвращайтесь к чтению.

Самое главное – это то, чтобы Вы ***поняли***.

#### Чистота

![Чистота в стакане](https://cdn-images-1.medium.com/max/800/1*lHMDe_A2Cs_4InZ-E9Da9A.png)

Если говорится о чистоте в функциональном программировании, значит подразумеваются чистые функции.

Чистые функции – очень простые. Они всего лишь производят операция над входными данными.

Вот пример чистой функции:

```js
var z = 10;
function add(x, y) {
    return x + y;
}
```

Заметьте, что функция ___add___ не прикасается к переменной ___z___. Она не читает её значения и ничего не пишет в неё. Функция читает только ___x___ и ___y___, свои входные данные, и возвращает результат их суммы.

Это и есть чистая функция. Если функция ___add___ имеет доступ к переменной ___z___, она больше не может быть чистой.

Это пример другой чистой функции:

```js
function justTen() {
    return 10;
}
```

Если функция ___justTen___ чистая, она может возвращать только значение-константу. Почему?

Потому что мы не даём ей никаких входных данных. А значит, чтобы быть чистой, она не должна изменять никаких переменных, кроме тех, что были ей переданы. Единственное, что может возвратить такая функция – константа.

Пока функции, не принимающие параметров, не работают, они не очень полезны. Было бы лучше объявить ___justTen___ просто как константу.

> *Более ___полезные___ чистые функции принимают хотя бы один параметр*.

Взгляните на этот пример:

```js
function addNoReturn(x, y) {
    var z = x + y
}
```

Посмотрите, эта функция ничего не возвращает. Она складывает ___x___ и ___y___, записывает результат в переменную ___z___, но не возвращает её.

Эта чистая функция работает только с входными данными. Да, она выполняет сложение, но пока ничего вернётся обратно, функция бесполезна.

> *Все ___полезные___ чистые функции должны возвращать что-нибудь*.

Давайте рассмотрим пример с первой функцией ___add___ ещё раз:

```js
function add(x, y) {
    return x + y;
}
console.log(add(1, 2)); // выводит 3
console.log(add(1, 2)); // всё ещё выводит 3
console.log(add(1, 2)); // БУДЕТ ВСЕГДА выводить 3
```

Обратите внимание, что ___add(1, 2)___ – в результате всегда даёт ___3___. Не большой сюрприз, конечно, но это потому что функция чистая. Если бы функция ___add___ брала значение откуда-то снаружи, Вы бы ___никогда___ не могли наверняка предсказать её поведение.

> *Чистая функция ___всегда___ возвращает одинаковые значения для одинаковых входных данных*.

Поскольку чистые функции не могут изменять внешние переменные, все эти функции являются ___нечистыми___:

```js
writeFile(fileName);
updateDatabaseTable(sqlCmd);
sendAjaxRequest(ajaxRequest);
openSocket(ipAddress);
```

Все функции в примере имеют то, что называют ___побочными эффектами___. Когда Вы вызываете их, они меняют файлы и таблицы баз данных, отправляют данные на сервер или обращаются к операционной системе, чтобы получить сокет. Они делают куда больше, чем просто оперирование входными данными и возвращение значений. Следовательно, Вы никогда не можете предсказать, что функция возвратит.

> *Чистые функции ___не___ имеют побочных эффектов.*

В таких языках императивного программирования как JavaScript, Java и C# побочные эффекты ___везде___. Это делает отладку проблематичной, потому что в коде Вашей программы переменная может быть изменена ___где угодно___. В общем если у Вас баг из-за переменой, принявшей неверное значение в неподходящее время, где Вы будете искать ошибку? Везде? Так дело не пойдёт.

На этом месте, Вы, вероятно, думаете: "КАК, ЧЁРТ ПОБЕРИ, Я СДЕЛАЮ ХОТЬ ЧТО-НИБУДЬ **ОДНИМИ ТОЛЬКО** ЧИСТЫМИ ФУНКЦИЯМИ?"

В функциональном программировании Вы не пишите только чистые функции.

Функциональные языки не могут исключить побочных эффектов, они могут только изолировать их. Пока у программ будут интерфейсы, взаимодействующие с реальным миром, некоторые части любой программы должны быть нечистыми. Цель – это свести к минимуму количество нечистого кода и отделить его от остальной части программы.

#### Неизменяемость

![Непреложный идеал вечного](https://cdn-images-1.medium.com/max/800/1*wKAhKZPXmcSwnq2AcLN-9Q.jpeg)

Вы помните, когда впервые увидели следующий код:
```js
var x = 1;
x = x + 1;
```

И тот, кто учил Вас программированию, говорил забыть изученное на уроках математики. Ведь в математике ***x*** никогда не мог равняться ***x + 1***.

Но в императивном программировании данный код означает «взять текущее значение ***x***, прибавить к нему ***1***, положить результат *обратно в* ***x***».

Что ж, в функциональном программировании выражение ***x = x + 1*** недопустимо. Так что Вам надо ***вспомнить*** то, что Вы ***забыли*** из математики... Если так можно выразиться.

> *В функциональном программировании ***нет*** переменных.*

Сохранённые значения всё ещё называются переменными по историческим причинам, но они являются константами, то есть ***x***, однажды приняв какое-либо значение, сохраняет его на всю жизнь.

Не волнуйтесь, ***x*** – это обычно локальная переменная, так что её жизнь достаточно коротка. Но пока она жива, она никак не изменится.

Вот пример переменной-константы в Elm, чистом языке функционального программирования для Web-разработки:

```elm
addOneToSum y z =
    let
        x = 1
    in
        x + y + z
```

Если вы не знакомы с синтаксисом языка программирования ML, позвольте мне объяснить. ***addOneToSum*** – это функция, принимающая 2 параметра: ***y*** и ***z***. 

Внутри блока ***let*** ***x*** приписывается значение 1, то есть он равен 1 до конца своей жизни. Его жизнь кончается, когда происходит выход из функции, или, более точно, когда определяется блок ***let**.

Внутри блока ***in*** вычисления могут включать значения, объявленные в блоке ***let***, а именно: ***x***. Возвращается результат вычисления ***x + y + z*** или, в точности, возвращается ***1 + x + y*** , так как ***x = 1***.

И снова я могу услышать, как вы вопрошаете: "КАК, ЧЕРТ ПОБЕРИ, Я ДОЛЖЕН СДЕЛАТЬ ХОТЬ ЧТО-НИБУДЬ БЕЗ ПЕРЕМЕННЫХ?!"

Давайте подумаем, когда обычно мы хотим изменить переменную. Всего 2 основных причины, которые приходят на ум: многозначные изменения (например, изменение отдельного значения объекта или записи) и однозначные изменения (например, счётчики цикла).

Функциональное программирование решает проблему изменений значения записи, делая копию уже изменённой записи. Это происходит оперативно, без копирования всех частей записи, используя определённые структуры данных, делающие это возможным.

Функциональное программирование решает также проблему однозначных изменений переменных, в сущности, тем же путём, просто делая их копию.

Да, кстати, и всё это ***без*** циклов. 

"СНАЧАЛА БЕЗ ПЕРЕМЕННЫХ, А ТЕПЕРЬ ЕЩЁ И БЕЗ ЦИКЛОВ? Я ТЕБЯ НЕНАВИЖУ!!!"

Попридержите коней. Это не значит, что мы не можем использовать циклы, просто здесь нет таких характерных операторов как ***for***, ***while***, ***do***, ***repeat*** и так далее.

> *Функциональное программирование использует рекурсию для выполнения цикла.*

Вот два примера реализации цикла в JavaScript.

```js
// простой оператор цикла
var acc = 0;
for (var i = 1; i <= 10; ++i)
    acc += i;
console.log(acc); // выводит 55

// без оператора цикла или переменных (рекурсия)
function sumRange(start, end, acc) {
    if (start > end)
        return acc;
    return sumRange(start + 1, end, acc + start)
}
console.log(sumRange(1, 10, 0)); // выводит 55
```

Обратите внимание, как рекурсия в функциональном подходе осуществляет то же, что и оператор цикла ***for***, вызывая саму себя с *новым* параметром запуска ***(start + 1)*** и с *новым* счетчиком ***(acc + start)***. Она не изменяет старых значений. Вместо этого она использует новые значения, высчитанные из старых.

К сожалению, такие примеры не очевидны в JavaScript, даже если Вы потратили некоторое время на его изучение, по двум причинам. Во-первых, синтаксис JavaScript засорён, а во-вторых, Вы, вероятно, не привыкли думать рекурсивно. 

Пример на языке Elm читать и, следовательно, понимать легче: 

```elm
sumRange start end acc =
    if start > end then
        acc
    else
        sumRange (start + 1) end (acc + start)

```

Так этот код выполняется:

```elm
sumRange 1 10 0 =      -- sumRange (1 + 1)  10 (0 + 1)
sumRange 2 10 1 =      -- sumRange (2 + 1)  10 (1 + 2)
sumRange 3 10 3 =      -- sumRange (3 + 1)  10 (3 + 3)
sumRange 4 10 6 =      -- sumRange (4 + 1)  10 (6 + 4)
sumRange 5 10 10 =     -- sumRange (5 + 1)  10 (10 + 5)
sumRange 6 10 15 =     -- sumRange (6 + 1)  10 (15 + 6)
sumRange 7 10 21 =     -- sumRange (7 + 1)  10 (21 + 7)
sumRange 8 10 28 =     -- sumRange (8 + 1)  10 (28 + 8)
sumRange 9 10 36 =     -- sumRange (9 + 1)  10 (36 + 9)
sumRange 10 10 45 =    -- sumRange (10 + 1) 10 (45 + 10)
sumRange 11 10 55 =    -- 11 > 10 => 55
55
```

Вам скорее всего кажется, что циклы ***for*** гораздо легче для понимания. Хотя это спорно и скорее всего является вопросом ***осведомлённости***, не-рекурсивные циклы подразумевают изменчивость, что по своей сути плохо.

Я не объясняю здесь преимущества использования парадигмы неизменяемости, но Вы можете посмотреть параграф под названием ***Global Mutable State*** в статье [Why Programmers Need Limits](https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db), если хотите изучить эту тему.

Одно очевидное преимущество – то, что если Вы имеете доступ к какому-либо значению в Вашей программе, это доступ только для чтения, а значит никто другой не может изменить это значение. Даже Вы сами. Вследствие, никаких случайных изменений. 

Также, если программа многопоточная, исполнение никакого потока не разрушит Ваши планы. Поскольку значение – константа и если поток захочет изменить его, ему придётся создать новое значение из старого.

Ещё в середине 90-х я написал игровой движок для [Creator Crunch](https://www.youtube.com/watch?v=uIOYSjBRORM) и самый большой источник ошибок был связан с вопросом многопоточности. Я хотел бы знать про неизменяемость в то время. Но тогда меня больше волновала разница между 2x и 4x скоростью приводов CD-ROM при игре.

> *Неизменяемость делает код проще и безопаснее.*

#### Мой мозг!!!!

![Условная инструкция что делать, если Вы правда так сказали](https://cdn-images-1.medium.com/max/800/1*IK5485-iZaHeZRfP8aWmYg.png)

Пока что достаточно.

В последующих частях этой статьи, я расскажу про функции более высокого порядка, функциональную композицию, каррирование и ещё много о чём.

***

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/%D0%B4%D0%B5%D0%B2%D1%88%D0%B0%D1%85%D1%82%D0%B0/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*
[Статья на Medium](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)