# Итак Вы хотите научиться функциональному программированию (Часть 1)
*Перевод статьи [Charles Scalfani](https://medium.com/@cscalfani): [So You Want to be a Functional Programmer (Part 1)](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)*
![Эволюция парадигм программирования](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png)
Первый шаг в понимании идеи функционального программирования -- самый важный и иногда самый сложный шаг. Но с верным подходом к задаче трудностей возникнуть не должно.
#### Обучение вождению

![Первое занятие по вождению](https://cdn-images-1.medium.com/max/800/1*3aCyRpNew24v3PLXxu4VxQ.png)

Когда мы только учились водить машину, мы старались изо всех сил. Конечно, это выглядело легко, когда мы смотрели как это делают другие люди. Но всё оказывалось сложнее, чем нам казалось.

Мы практиковались на машине родителей и не выезжали на автострады, пока в совершенстве не осваивали улицы родного района.

После множества практических занятий и нескольких весьма волнующих моментов, о которых наши родители хотели бы забыть, мы научились водить и наконец получали свои водительские права.

С правами в руках мы садились за руль при любом удобном случае. С каждой новой поездкой наши навыки становились всё лучше и лучше, уверенность росла. Затем наступал день, когда нам приходилось вести чью-то другую машину или наша собственная приказывала долго жить и мы покупали новую.

На что это было похоже -- первый раз за рулём ***другой машины***? Было ли это похоже на ***самый первый раз*** за рулём машины вообще? Даже не близко. В первый раз всё было таким незнакомым. Конечно, мы были до этого в машине, но только в роли пассажира. На этот раз мы оказывались в сиденьи водителя. Один на один со всеми рычагами, кнопками и педалями.

Но когда мы уже вели нашу вторую машину, мы просто задавали себе несколько простых вопросов по типу: куда вставляется ключ, где переключаются фары ближнего и дальнего света, как использовать поворотники и как настроить зеркала заднего вида. 

После всего этого мы ведём свою машину как по маслу. Но почему в этот раз всё было так просто по сравнению с первым разом?

Потому что новая машина была достаточно похожа на старую. Она имела все те базовые элементы, что нужны машине, и в большинстве случаев они находились на тех же местах, что и в старой.

Может, несколько вещей были реализованы как-то иначе и, может быть, они имели какие-то дополнительные функциональные возможности, но мы итак не использовали их во всём нашем водительском опыте. В конце концов мы изучали и эти новые особенности. Как минимум, те, что нам требовались.

Что же, процесс изучения языков программирования похож на процесс обучения вождению. Первые усилия -- самые тяжёлые. Но с багажом опыта за плечами, всё последующее обучение стновится проще и проще.

Когда Вы начинаете изучать второй язык, Вы спрашиваете себя: "Как мне создать модуль? Как реализовать поиск по массиву? Какие параметры принимает функция нахождения подстроки?"

Вы уверены, что можете "научиться водить" на этом новом языке, потому что он напоминает Вам о Вашем старом языке, может быть, с несколькими новыми элементами, которые вероятно сделают Вашу жизнь легче.

#### Ваш первый космический корабль

![Вы за штурвалом космического корабля](https://cdn-images-1.medium.com/max/800/1*ZLJIz9OrgCHCTST9KOcHIQ.png)

Ездили ли Вы на одном автомобиле всю свою жизнь или на десятках автомобилях, представьте, что собираетесь сесть за штурвал космического корабля. 

Если Вы собираетесь летать на таком аппарате, то вряд ли будете ожидать, что навыки вождения по дороге особенно Вам помогут. Вы начнёте всё с нуля (*Мы же программисты, чёрт возьми. Мы начинаем считать с нуля*.)

Вы начнёте свои тренировки с расчётом, что все вещи в космосе существуют иначе и что полёты на этой штуковине довольно отличны от поездок по земле.

Однако физика не изменилась. Путь, по которому вы двигаетесь находится в пределах всё той же Вселенной. 

И это то же самое, что учить функциональное программирование. Вы должны учитывать, что всё будет по-другому. И то многое, что Вы знали о программировании не будет перенесено в новую область.

Программировать -- значит мыслить и функциональное программирование научит Вас мыслить совсем по-другому настолько, что Вы вероятно никогда не вернётесь назад на старый путь образа мышления.  

#### Забудьте всё, что Вы знаете

![Один из вариантов как забыть всё](https://cdn-images-1.medium.com/max/800/1*PoIg8NuGaH3XQkQ8Ctz6hw.png)

Многие люди любят говорить эту фразу, но в ней есть доля правды. ***Начать изучение функционального программирования значит начать всё с нуля***. Не полностью, конечно, но фактически это так. В этой теме существует множество простых концепций, но Вам лучше приготовиться к тому, что придётся *** переучивать всё***.

С правильным подходом Вы будете видеть будущие переспективы, а с будущими переспективами Вы не захотите бросить дело, когда начнутся вещи по-тяжелее.

Есть также многие вещи, которые Вы привыкли делать, как программист, но которые Вы не сможете больше делать, занимаясь функциональным программированием.

Вспомните, как Вы, чтобы выехать с проезжей части, давали задний ход на машине. Но на космическом корабле нет заднего хода. Теперь Вы должны подумать: "ЧТО? НЕТ ЗАДНЕГО ХОДА? КАК Я ДОЛЖЕН ВОДИТЬ БЕЗ ЗАДНЕГО ХОДА?"

Что ж, оказывается Вам не нужен задний привод на космическом корабле, способном маневрировать в трёхмерном пространстве космоса. Как только Вы поймёте это, Вы больше не будете вспоминать о возможности заднего хода. На самом деле, однажды, Вы даже задумаетесь о том, насколько ограничены были обыкновенные машины.

> *Изучение функционального программирования требует времени. Так что запаситесь терпением*.

Так что давайте покинем холодный мир императивного программирования и плавно окунёмся в горячие источники функционального программирования.

То, что следует в этих составных статьях -- концепции функционального программирования, которые помогут Вам перед полным погружением в первый функциональный язык. Или, если Вы уже сделали решительный шаг в этой сфере, эти статьи помогут заточить понимание идей. 

Пожалуйста, не спешите. С этого момента не торопитесь и находите время, чтобы понять примеры кода. Лучше будет даже сделать небольшую паузу в прочтении после этой части статьи и дать озвученным идеям "устаканиться". Затем возвращайтесь к чтению.

Самая важная вещь -- это то, чтобы Вы ***поняли***.

#### Чистота

![Чистота в стакане](https://cdn-images-1.medium.com/max/800/1*lHMDe_A2Cs_4InZ-E9Da9A.png)

Если говориться о чистоте в функциональном программирование, значит подразумеваются чистые функции.

Чистые функции -- очень простые. Они всего лишь производят операция над входными данными.

Вот пример чистой функции:

```js
var z = 10;
function add(x, y) {
    return x + y;
}
```

Заметьте, что функция ___add___ не прикасается к переменной ___z___. Она не читает её значения и ничего не пишет в неё. Функция читает только ___x___ и ___y___, свои входные данные, и возвращает результат их суммы.

Это и есть чистая функция. Если функция ___add___ имелся доступ к переменной ___z___, она больше не была чистой.

Это пример другой чистой функции:

```js
function justTen() {
    return 10;
}
```

Если функция ___justTen___ чистая, она может возвращать только значение-константу. Почему?

Потому что мы не даём ей никаких входных данных. А значит, чтобы быть чистой, она не должна изменять никаких переменных, кроме тех, что были ей переданы. Единственное, что может возвратить такая функция -- константа.

Пока функции, не принимающие параметров, не работают, они не очень полезны. Было бы лучше объявить ___justTen___ просто как константу.

> *Более ___полезные___ чистые функции принимают хотя бы один параметр*.

Взгляните на этот пример:

```js
function addNoReturn(x, y) {
    var z = x + y
}
```

Посмотрите, эта функция ничего не возвращает. Она складывает ___x___ и ___y___, записывает результат в переменную ___z___, но не возвращает её.

Эта чистая функция работает только с входными данными. Да, она выполняет сложение, но пока ничего вернётся обратно, функция бесполезна.

> *Все ___полезные___ чистые функции должны возвращать что-нибудь*.

Давайте рассмотрим пример с первой функцией ___add___ ещё раз:

```js
function add(x, y) {
    return x + y;
}
console.log(add(1, 2)); // выводит 3
console.log(add(1, 2)); // всё ещё выводит 3
console.log(add(1, 2)); // БУДЕТ ВСЕГДА выводить 3
```

Обратите внимание, что ___add(1, 2)___ -- в результате всегда даёт ___3___. Не большой сюрприз, конечно, но это потому что функция чистая. Если бы функция ___add___ брала значение откуда-то снаружи, Вы бы ___никогда___ не могли наверняка предсказать её поведение.

> *Чистая функция ___всегда___ возвращает одинаковые значения для одинаковых входных данных*.

Если все чистые функции не могут изменять внешние переменные, то все эти функции являются ___нечистыми___:

```js
writeFile(fileName);
updateDatabaseTable(sqlCmd);
sendAjaxRequest(ajaxRequest);
openSocket(ipAddress);
```

Все функции в примере имеют то, что называют ___побочными эффектами___. Когда Вы вызываете их, они меняют файлы и таблицы баз данных, отправляют данные на сервер или обращаются к операционной системе, чтобы получить сокет. Они делают куда больше, чем просто оперирование входными данными и возвращение значений. Следовательно, Вы никогда не можете предсказать, что функция возвратит.

> Чистые функции ___не___ имеют побочных эффектов.

В таких языках императививного программирования как JavaScript, Java и C# побочные эффекты ___везде___. Это делает дебаггинг очень сложным, потому что в коде Вашей программы переменная может быть изменена ___где угодно___. В общем если у Вас баг из-за переменой, принявшей неверное значение за неверное время, где Вы будете искать ошибку? Везде? Так дело не пойдёт.

На этом месте, Вы, вероятно, думаете: "КАКОГО ДЬЯВОЛА Я СДЕЛАЮ ХОТЬ ЧТО-НИБУДЬ **ОДНИМИ ТОЛЬКО** ЧИСТЫМИ ФУНКЦИЯМИ?"

В функциональном программировании Вы не пишите просто чистые функции.

Функциональные языки не могут исключить побочных эффектов, они могут только изолировать их. Пока у программ будут интерфейсы, взаимодействующие с реальным миром, некоторые части любой программы должны быть нечистыми. Цель -- это свести к минимуму количество нечистого кода и отделить его от остальной части программы.

***
*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/%D0%B4%D0%B5%D0%B2%D1%88%D0%B0%D1%85%D1%82%D0%B0/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*
[Статья на Medium](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)